# é—®é¢˜è¯Šæ–­ä¸è§£å†³

## ğŸ“‹ ç›®å½•

- [é—®é¢˜è¯Šæ–­ä¸è§£å†³](#é—®é¢˜è¯Šæ–­ä¸è§£å†³)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. è¯Šæ–­æ–¹æ³•è®º](#1-è¯Šæ–­æ–¹æ³•è®º)
    - [1.1 ç³»ç»ŸåŒ–è¯Šæ–­æµç¨‹](#11-ç³»ç»ŸåŒ–è¯Šæ–­æµç¨‹)
    - [1.2 æ—¥å¿—åˆ†æ](#12-æ—¥å¿—åˆ†æ)
    - [1.3 æ€§èƒ½ç›‘æ§](#13-æ€§èƒ½ç›‘æ§)
  - [2. èŠ‚ç‚¹é—®é¢˜](#2-èŠ‚ç‚¹é—®é¢˜)
    - [2.1 èŠ‚ç‚¹æ— æ³•å¯åŠ¨](#21-èŠ‚ç‚¹æ— æ³•å¯åŠ¨)
    - [2.2 èŠ‚ç‚¹åŒæ­¥å¤±è´¥](#22-èŠ‚ç‚¹åŒæ­¥å¤±è´¥)
    - [2.3 èŠ‚ç‚¹é¢‘ç¹å´©æºƒ](#23-èŠ‚ç‚¹é¢‘ç¹å´©æºƒ)
  - [3. å…±è¯†é—®é¢˜](#3-å…±è¯†é—®é¢˜)
    - [3.1 å…±è¯†å¤±è´¥](#31-å…±è¯†å¤±è´¥)
    - [3.2 åˆ†å‰é—®é¢˜](#32-åˆ†å‰é—®é¢˜)
    - [3.3 ç½‘ç»œåˆ†åŒº](#33-ç½‘ç»œåˆ†åŒº)
  - [4. äº¤æ˜“é—®é¢˜](#4-äº¤æ˜“é—®é¢˜)
    - [4.1 äº¤æ˜“pending](#41-äº¤æ˜“pending)
    - [4.2 äº¤æ˜“å¤±è´¥](#42-äº¤æ˜“å¤±è´¥)
    - [4.3 Gasä¼°ç®—é”™è¯¯](#43-gasä¼°ç®—é”™è¯¯)
  - [5. æ™ºèƒ½åˆçº¦é—®é¢˜](#5-æ™ºèƒ½åˆçº¦é—®é¢˜)
    - [5.1 åˆçº¦éƒ¨ç½²å¤±è´¥](#51-åˆçº¦éƒ¨ç½²å¤±è´¥)
    - [5.2 åˆçº¦è°ƒç”¨é”™è¯¯](#52-åˆçº¦è°ƒç”¨é”™è¯¯)
    - [5.3 åˆçº¦å®‰å…¨æ¼æ´](#53-åˆçº¦å®‰å…¨æ¼æ´)
  - [6. ç½‘ç»œé—®é¢˜](#6-ç½‘ç»œé—®é¢˜)
    - [6.1 P2Pè¿æ¥é—®é¢˜](#61-p2pè¿æ¥é—®é¢˜)
    - [6.2 ç½‘ç»œå»¶è¿Ÿé«˜](#62-ç½‘ç»œå»¶è¿Ÿé«˜)
    - [6.3 DDoSæ”»å‡»](#63-ddosæ”»å‡»)
  - [7. å­˜å‚¨é—®é¢˜](#7-å­˜å‚¨é—®é¢˜)
    - [7.1 æ•°æ®åº“æŸå](#71-æ•°æ®åº“æŸå)
    - [7.2 ç£ç›˜ç©ºé—´ä¸è¶³](#72-ç£ç›˜ç©ºé—´ä¸è¶³)
    - [7.3 æ•°æ®åŒæ­¥æ…¢](#73-æ•°æ®åŒæ­¥æ…¢)
  - [8. æ€§èƒ½é—®é¢˜](#8-æ€§èƒ½é—®é¢˜)
    - [8.1 TPSä½](#81-tpsä½)
    - [8.2 å†…å­˜æ³„æ¼](#82-å†…å­˜æ³„æ¼)
    - [8.3 CPUå ç”¨é«˜](#83-cpuå ç”¨é«˜)
  - [9. å®‰å…¨é—®é¢˜](#9-å®‰å…¨é—®é¢˜)
    - [9.1 ç§é’¥æ³„éœ²](#91-ç§é’¥æ³„éœ²)
    - [9.2 51%æ”»å‡»](#92-51æ”»å‡»)
    - [9.3 å¥³å·«æ”»å‡»](#93-å¥³å·«æ”»å‡»)
  - [10. å·¥å…·ä¸æœ€ä½³å®è·µ](#10-å·¥å…·ä¸æœ€ä½³å®è·µ)
    - [10.1 è¯Šæ–­å·¥å…·](#101-è¯Šæ–­å·¥å…·)
    - [10.2 ç›‘æ§å·¥å…·](#102-ç›‘æ§å·¥å…·)
    - [10.3 æœ€ä½³å®è·µ](#103-æœ€ä½³å®è·µ)
  - [æ€»ç»“](#æ€»ç»“)

## 1. è¯Šæ–­æ–¹æ³•è®º

### 1.1 ç³»ç»ŸåŒ–è¯Šæ–­æµç¨‹

```rust
/// ç³»ç»ŸåŒ–æ•…éšœè¯Šæ–­æ¡†æ¶
pub struct TroubleshootingFramework {
    diagnostic_steps: Vec<DiagnosticStep>,
    troubleshooting_tools: Vec<Tool>,
}

#[derive(Debug)]
pub struct DiagnosticStep {
    step_number: u32,
    name: &'static str,
    actions: Vec<&'static str>,
    expected_outcome: &'static str,
}

#[derive(Debug)]
pub struct Tool {
    name: &'static str,
    purpose: &'static str,
    usage: &'static str,
}

impl TroubleshootingFramework {
    pub fn new() -> Self {
        Self {
            diagnostic_steps: vec![
                DiagnosticStep {
                    step_number: 1,
                    name: "é—®é¢˜è¯†åˆ«",
                    actions: vec![
                        "æ”¶é›†ç—‡çŠ¶æè¿°",
                        "ç¡®å®šå½±å“èŒƒå›´",
                        "æ£€æŸ¥é”™è¯¯æ—¥å¿—",
                        "è®°å½•é—®é¢˜å‘ç”Ÿæ—¶é—´",
                    ],
                    expected_outcome: "æ¸…æ¥šå®šä¹‰é—®é¢˜",
                },
                DiagnosticStep {
                    step_number: 2,
                    name: "ä¿¡æ¯æ”¶é›†",
                    actions: vec![
                        "æŸ¥çœ‹ç³»ç»Ÿæ—¥å¿—",
                        "æ£€æŸ¥èµ„æºä½¿ç”¨æƒ…å†µ",
                        "è·å–ç½‘ç»œçŠ¶æ€",
                        "å¯¼å‡ºé…ç½®æ–‡ä»¶",
                    ],
                    expected_outcome: "å®Œæ•´çš„è¯Šæ–­æ•°æ®",
                },
                DiagnosticStep {
                    step_number: 3,
                    name: "å‡è®¾æå‡º",
                    actions: vec![
                        "åˆ†æå¯èƒ½åŸå› ",
                        "æ ¹æ®ç»éªŒæ’åº",
                        "å‚è€ƒçŸ¥è¯†åº“",
                    ],
                    expected_outcome: "ä¼˜å…ˆçº§æ’åºçš„å‡è®¾åˆ—è¡¨",
                },
                DiagnosticStep {
                    step_number: 4,
                    name: "æµ‹è¯•éªŒè¯",
                    actions: vec![
                        "é€ä¸€æµ‹è¯•å‡è®¾",
                        "è®°å½•æµ‹è¯•ç»“æœ",
                        "æ’é™¤ä¸å¯èƒ½åŸå› ",
                    ],
                    expected_outcome: "ç¡®è®¤æ ¹æœ¬åŸå› ",
                },
                DiagnosticStep {
                    step_number: 5,
                    name: "è§£å†³æ–¹æ¡ˆ",
                    actions: vec![
                        "åˆ¶å®šä¿®å¤æ–¹æ¡ˆ",
                        "è¯„ä¼°é£é™©",
                        "å‡†å¤‡å›æ»šè®¡åˆ’",
                        "æ‰§è¡Œä¿®å¤",
                    ],
                    expected_outcome: "é—®é¢˜è§£å†³",
                },
                DiagnosticStep {
                    step_number: 6,
                    name: "éªŒè¯ä¸æ–‡æ¡£",
                    actions: vec![
                        "éªŒè¯ä¿®å¤æ•ˆæœ",
                        "ç›‘æ§ç³»ç»Ÿè¿è¡Œ",
                        "æ›´æ–°çŸ¥è¯†åº“",
                        "æ€»ç»“ç»éªŒæ•™è®­",
                    ],
                    expected_outcome: "ç³»ç»Ÿæ¢å¤æ­£å¸¸ï¼Œæ–‡æ¡£æ›´æ–°",
                },
            ],
            troubleshooting_tools: vec![
                Tool {
                    name: "æ—¥å¿—åˆ†æå·¥å…·",
                    purpose: "åˆ†æç³»ç»Ÿå’Œåº”ç”¨æ—¥å¿—",
                    usage: "tail -f /var/log/blockchain/node.log",
                },
                Tool {
                    name: "ç½‘ç»œè¯Šæ–­å·¥å…·",
                    purpose: "æ£€æŸ¥ç½‘ç»œè¿æ¥",
                    usage: "netstat -an | grep ESTABLISHED",
                },
                Tool {
                    name: "æ€§èƒ½ç›‘æ§å·¥å…·",
                    purpose: "ç›‘æ§èµ„æºä½¿ç”¨",
                    usage: "htop, iostat, vmstat",
                },
            ],
        }
    }
    
    /// è¯Šæ–­æ£€æŸ¥æ¸…å•
    pub fn diagnostic_checklist(&self) -> DiagnosticChecklist {
        DiagnosticChecklist {
            system_level: vec![
                "[ ] CPUä½¿ç”¨ç‡æ­£å¸¸ï¼ˆ<80%ï¼‰",
                "[ ] å†…å­˜å……è¶³ï¼ˆ>20%å¯ç”¨ï¼‰",
                "[ ] ç£ç›˜ç©ºé—´è¶³å¤Ÿï¼ˆ>20%å¯ç”¨ï¼‰",
                "[ ] ç½‘ç»œè¿æ¥æ­£å¸¸",
                "[ ] æ—¶é—´åŒæ­¥æ­£ç¡®ï¼ˆNTPï¼‰",
            ],
            application_level: vec![
                "[ ] èŠ‚ç‚¹è¿›ç¨‹è¿è¡Œä¸­",
                "[ ] é…ç½®æ–‡ä»¶æ­£ç¡®",
                "[ ] æ—¥å¿—æ— errorçº§åˆ«é”™è¯¯",
                "[ ] æ•°æ®åº“è¿æ¥æ­£å¸¸",
                "[ ] APIå“åº”æ­£å¸¸",
            ],
            blockchain_level: vec![
                "[ ] åŒºå—é«˜åº¦åŒæ­¥",
                "[ ] äº¤æ˜“æ± æ­£å¸¸",
                "[ ] å…±è¯†å‚ä¸æ­£å¸¸",
                "[ ] P2Pè¿æ¥æ•°æ­£å¸¸ï¼ˆ>3ï¼‰",
                "[ ] åŒºå—éªŒè¯é€šè¿‡",
            ],
        }
    }
}

#[derive(Debug)]
pub struct DiagnosticChecklist {
    system_level: Vec<&'static str>,
    application_level: Vec<&'static str>,
    blockchain_level: Vec<&'static str>,
}
```

### 1.2 æ—¥å¿—åˆ†æ

```rust
/// æ—¥å¿—åˆ†æå·¥å…·
pub struct LogAnalyzer {
    log_patterns: Vec<LogPattern>,
}

#[derive(Debug)]
pub struct LogPattern {
    pattern: &'static str,
    severity: Severity,
    possible_causes: Vec<&'static str>,
    recommended_actions: Vec<&'static str>,
}

#[derive(Debug)]
pub enum Severity {
    Critical,
    Error,
    Warning,
    Info,
}

impl LogAnalyzer {
    pub fn new() -> Self {
        Self {
            log_patterns: vec![
                LogPattern {
                    pattern: "panic: runtime error",
                    severity: Severity::Critical,
                    possible_causes: vec![
                        "ç©ºæŒ‡é’ˆå¼•ç”¨",
                        "æ•°ç»„è¶Šç•Œ",
                        "ç±»å‹æ–­è¨€å¤±è´¥",
                    ],
                    recommended_actions: vec![
                        "æŸ¥çœ‹panicè°ƒç”¨æ ˆ",
                        "æ£€æŸ¥ä»£ç é€»è¾‘",
                        "æ·»åŠ è¾¹ç•Œæ£€æŸ¥",
                    ],
                },
                LogPattern {
                    pattern: "connection refused",
                    severity: Severity::Error,
                    possible_causes: vec![
                        "æœåŠ¡æœªå¯åŠ¨",
                        "ç«¯å£è¢«å ç”¨",
                        "é˜²ç«å¢™é˜»æ­¢",
                        "ç½‘ç»œä¸é€š",
                    ],
                    recommended_actions: vec![
                        "æ£€æŸ¥æœåŠ¡çŠ¶æ€",
                        "éªŒè¯ç«¯å£é…ç½®",
                        "æ£€æŸ¥é˜²ç«å¢™è§„åˆ™",
                        "æµ‹è¯•ç½‘ç»œè¿é€šæ€§",
                    ],
                },
                LogPattern {
                    pattern: "database locked",
                    severity: Severity::Warning,
                    possible_causes: vec![
                        "å¹¶å‘å†™å…¥å†²çª",
                        "äº‹åŠ¡æœªæäº¤",
                        "æ­»é”",
                    ],
                    recommended_actions: vec![
                        "æ£€æŸ¥äº‹åŠ¡ç®¡ç†",
                        "å‡å°‘å¹¶å‘å†™å…¥",
                        "ä¼˜åŒ–æ•°æ®åº“é”ç­–ç•¥",
                    ],
                },
            ],
        }
    }
    
    /// åˆ†ææ—¥å¿—æ–‡ä»¶
    pub async fn analyze_logs(&self, log_path: &str) -> Result<AnalysisReport, Error> {
        // è¯»å–æ—¥å¿—æ–‡ä»¶
        let logs = self.read_logs(log_path).await?;
        
        // ç»Ÿè®¡é”™è¯¯æ¨¡å¼
        let error_stats = self.count_error_patterns(&logs)?;
        
        // æ—¶é—´åºåˆ—åˆ†æ
        let timeline = self.build_timeline(&logs)?;
        
        // ç”ŸæˆæŠ¥å‘Š
        Ok(AnalysisReport {
            total_lines: logs.len(),
            error_count: error_stats.errors,
            warning_count: error_stats.warnings,
            critical_count: error_stats.critical,
            timeline,
            recommendations: self.generate_recommendations(&error_stats),
        })
    }
    
    async fn read_logs(&self, path: &str) -> Result<Vec<LogEntry>, Error> {
        // è¯»å–æ—¥å¿—
        Ok(vec![])
    }
    
    fn count_error_patterns(&self, logs: &[LogEntry]) -> Result<ErrorStats, Error> {
        Ok(ErrorStats {
            errors: 0,
            warnings: 0,
            critical: 0,
        })
    }
    
    fn build_timeline(&self, logs: &[LogEntry]) -> Result<Vec<TimelineEvent>, Error> {
        Ok(vec![])
    }
    
    fn generate_recommendations(&self, stats: &ErrorStats) -> Vec<String> {
        vec![]
    }
}

#[derive(Debug)]
pub struct LogEntry {
    timestamp: SystemTime,
    level: String,
    message: String,
}

#[derive(Debug)]
pub struct ErrorStats {
    errors: u32,
    warnings: u32,
    critical: u32,
}

#[derive(Debug)]
pub struct TimelineEvent {
    time: SystemTime,
    event: String,
}

#[derive(Debug)]
pub struct AnalysisReport {
    total_lines: usize,
    error_count: u32,
    warning_count: u32,
    critical_count: u32,
    timeline: Vec<TimelineEvent>,
    recommendations: Vec<String>,
}
```

### 1.3 æ€§èƒ½ç›‘æ§

```rust
/// æ€§èƒ½ç›‘æ§ç³»ç»Ÿ
pub struct PerformanceMonitor {
    metrics: Vec<Metric>,
    thresholds: Thresholds,
}

#[derive(Debug)]
pub struct Metric {
    name: &'static str,
    current_value: f64,
    unit: &'static str,
}

#[derive(Debug)]
pub struct Thresholds {
    cpu_warning: f64,
    cpu_critical: f64,
    memory_warning: f64,
    memory_critical: f64,
    disk_warning: f64,
    disk_critical: f64,
}

impl PerformanceMonitor {
    pub fn new() -> Self {
        Self {
            metrics: vec![],
            thresholds: Thresholds {
                cpu_warning: 75.0,
                cpu_critical: 90.0,
                memory_warning: 80.0,
                memory_critical: 95.0,
                disk_warning: 80.0,
                disk_critical: 90.0,
            },
        }
    }
    
    /// æ”¶é›†ç³»ç»ŸæŒ‡æ ‡
    pub async fn collect_metrics(&mut self) -> Result<(), Error> {
        self.metrics = vec![
            self.get_cpu_usage().await?,
            self.get_memory_usage().await?,
            self.get_disk_usage().await?,
            self.get_network_throughput().await?,
        ];
        Ok(())
    }
    
    /// æ£€æŸ¥é˜ˆå€¼
    pub fn check_thresholds(&self) -> Vec<Alert> {
        let mut alerts = Vec::new();
        
        for metric in &self.metrics {
            match metric.name {
                "cpu_usage" => {
                    if metric.current_value >= self.thresholds.cpu_critical {
                        alerts.push(Alert {
                            severity: AlertSeverity::Critical,
                            metric: metric.name,
                            value: metric.current_value,
                            threshold: self.thresholds.cpu_critical,
                            message: "CPUä½¿ç”¨ç‡è¶…è¿‡ä¸´ç•Œå€¼",
                        });
                    } else if metric.current_value >= self.thresholds.cpu_warning {
                        alerts.push(Alert {
                            severity: AlertSeverity::Warning,
                            metric: metric.name,
                            value: metric.current_value,
                            threshold: self.thresholds.cpu_warning,
                            message: "CPUä½¿ç”¨ç‡åé«˜",
                        });
                    }
                },
                _ => {}
            }
        }
        
        alerts
    }
    
    async fn get_cpu_usage(&self) -> Result<Metric, Error> {
        Ok(Metric {
            name: "cpu_usage",
            current_value: 45.0,
            unit: "%",
        })
    }
    
    async fn get_memory_usage(&self) -> Result<Metric, Error> {
        Ok(Metric {
            name: "memory_usage",
            current_value: 60.0,
            unit: "%",
        })
    }
    
    async fn get_disk_usage(&self) -> Result<Metric, Error> {
        Ok(Metric {
            name: "disk_usage",
            current_value: 70.0,
            unit: "%",
        })
    }
    
    async fn get_network_throughput(&self) -> Result<Metric, Error> {
        Ok(Metric {
            name: "network_throughput",
            current_value: 125.5,
            unit: "Mbps",
        })
    }
}

#[derive(Debug)]
pub struct Alert {
    severity: AlertSeverity,
    metric: &'static str,
    value: f64,
    threshold: f64,
    message: &'static str,
}

#[derive(Debug)]
pub enum AlertSeverity {
    Warning,
    Critical,
}
```

## 2. èŠ‚ç‚¹é—®é¢˜

### 2.1 èŠ‚ç‚¹æ— æ³•å¯åŠ¨

```rust
/// èŠ‚ç‚¹å¯åŠ¨å¤±è´¥è¯Šæ–­
pub struct NodeStartupTroubleshooting;

impl NodeStartupTroubleshooting {
    /// å¸¸è§å¯åŠ¨å¤±è´¥åŸå› 
    pub fn common_issues() -> Vec<StartupIssue> {
        vec![
            StartupIssue {
                symptom: "ç«¯å£already in use",
                cause: "ç«¯å£è¢«å…¶ä»–è¿›ç¨‹å ç”¨",
                diagnosis: vec![
                    "lsof -i :8545",
                    "netstat -tulpn | grep 8545",
                ],
                solution: vec![
                    "killå ç”¨ç«¯å£çš„è¿›ç¨‹",
                    "ä¿®æ”¹é…ç½®ä½¿ç”¨å…¶ä»–ç«¯å£",
                    "systemctl stop blockchain-node",
                ],
            },
            StartupIssue {
                symptom: "permission denied",
                cause: "æƒé™ä¸è¶³",
                diagnosis: vec![
                    "ls -la /var/lib/blockchain",
                    "whoami",
                    "groups",
                ],
                solution: vec![
                    "sudo chown -R user:group /var/lib/blockchain",
                    "chmod 755 /var/lib/blockchain",
                    "ä»¥æ­£ç¡®ç”¨æˆ·èº«ä»½è¿è¡Œ",
                ],
            },
            StartupIssue {
                symptom: "database corrupted",
                cause: "æ•°æ®åº“æ–‡ä»¶æŸå",
                diagnosis: vec![
                    "æ£€æŸ¥ç£ç›˜ç©ºé—´",
                    "æŸ¥çœ‹æ•°æ®åº“æ—¥å¿—",
                    "å°è¯•æ•°æ®åº“ä¿®å¤å·¥å…·",
                ],
                solution: vec![
                    "å¤‡ä»½æ•°æ®",
                    "ä½¿ç”¨repairå·¥å…·ä¿®å¤",
                    "æœ€åæƒ…å†µï¼šåˆ é™¤æ•°æ®åº“é‡æ–°åŒæ­¥",
                ],
            },
            StartupIssue {
                symptom: "config parse error",
                cause: "é…ç½®æ–‡ä»¶æ ¼å¼é”™è¯¯",
                diagnosis: vec![
                    "cat config.toml",
                    "éªŒè¯JSON/TOMLæ ¼å¼",
                ],
                solution: vec![
                    "æ£€æŸ¥è¯­æ³•é”™è¯¯ï¼ˆé€—å·ã€å¼•å·ï¼‰",
                    "ä½¿ç”¨åœ¨çº¿éªŒè¯å·¥å…·",
                    "æ¢å¤é»˜è®¤é…ç½®",
                ],
            },
        ]
    }
    
    /// å¯åŠ¨å‰æ£€æŸ¥æ¸…å•
    pub fn pre_startup_checklist() -> Vec<&'static str> {
        vec![
            "[ ] é…ç½®æ–‡ä»¶å­˜åœ¨ä¸”æ ¼å¼æ­£ç¡®",
            "[ ] æ‰€éœ€ç«¯å£æœªè¢«å ç”¨",
            "[ ] æ–‡ä»¶æƒé™æ­£ç¡®",
            "[ ] ç£ç›˜ç©ºé—´å……è¶³ï¼ˆ>100GBæ¨èï¼‰",
            "[ ] ä¾èµ–æœåŠ¡è¿è¡Œï¼ˆæ•°æ®åº“ç­‰ï¼‰",
            "[ ] é˜²ç«å¢™è§„åˆ™é…ç½®",
            "[ ] ç½‘ç»œè¿é€šæ€§æµ‹è¯•",
        ]
    }
}

#[derive(Debug)]
pub struct StartupIssue {
    symptom: &'static str,
    cause: &'static str,
    diagnosis: Vec<&'static str>,
    solution: Vec<&'static str>,
}
```

### 2.2 èŠ‚ç‚¹åŒæ­¥å¤±è´¥

```rust
/// èŠ‚ç‚¹åŒæ­¥é—®é¢˜è¯Šæ–­
pub struct SyncTroubleshooting;

impl SyncTroubleshooting {
    pub fn common_sync_issues() -> Vec<SyncIssue> {
        vec![
            SyncIssue {
                symptom: "åŒæ­¥å¡ä½ä¸åŠ¨",
                possible_causes: vec![
                    "ç½‘ç»œé—®é¢˜",
                    "å¯¹ç­‰èŠ‚ç‚¹ä¸è¶³",
                    "æ•°æ®åº“æ€§èƒ½ç“¶é¢ˆ",
                    "åŒºå—éªŒè¯å¤±è´¥",
                ],
                diagnostic_steps: vec![
                    "æ£€æŸ¥å¯¹ç­‰èŠ‚ç‚¹æ•°é‡ï¼šblockchain-cli net peer-count",
                    "æŸ¥çœ‹åŒæ­¥çŠ¶æ€ï¼šblockchain-cli sync status",
                    "æ£€æŸ¥ç½‘ç»œè¿æ¥ï¼šping peer-node-ip",
                    "æŸ¥çœ‹æ—¥å¿—é”™è¯¯",
                ],
                solutions: vec![
                    "å¢åŠ å¯¹ç­‰èŠ‚ç‚¹",
                    "æ£€æŸ¥é˜²ç«å¢™é…ç½®",
                    "ä¼˜åŒ–æ•°æ®åº“é…ç½®",
                    "ä½¿ç”¨å¿«ç…§åŒæ­¥",
                ],
            },
            SyncIssue {
                symptom: "åŒæ­¥é€Ÿåº¦æ…¢",
                possible_causes: vec![
                    "ç½‘ç»œå¸¦å®½é™åˆ¶",
                    "ç£ç›˜I/Oæ…¢",
                    "CPUè®¡ç®—æ…¢",
                ],
                diagnostic_steps: vec![
                    "iftop -i eth0ï¼ˆç›‘æ§ç½‘ç»œï¼‰",
                    "iostat -x 1ï¼ˆç›‘æ§ç£ç›˜ï¼‰",
                    "topï¼ˆç›‘æ§CPUï¼‰",
                ],
                solutions: vec![
                    "ä½¿ç”¨SSD",
                    "å¢åŠ peersæ•°é‡",
                    "è°ƒæ•´cacheå¤§å°",
                    "å¯ç”¨å¿«é€ŸåŒæ­¥æ¨¡å¼",
                ],
            },
        ]
    }
}

#[derive(Debug)]
pub struct SyncIssue {
    symptom: &'static str,
    possible_causes: Vec<&'static str>,
    diagnostic_steps: Vec<&'static str>,
    solutions: Vec<&'static str>,
}
```

### 2.3 èŠ‚ç‚¹é¢‘ç¹å´©æºƒ

```rust
/// èŠ‚ç‚¹å´©æºƒé—®é¢˜è¯Šæ–­
pub struct NodeCrashTroubleshooting;

impl NodeCrashTroubleshooting {
    pub fn analyze_crash() -> CrashAnalysis {
        CrashAnalysis {
            data_collection: vec![
                "æ”¶é›†coredumpæ–‡ä»¶",
                "è·å–panicå †æ ˆä¿¡æ¯",
                "æŸ¥çœ‹ç³»ç»Ÿæ—¥å¿—ï¼šjournalctl -u blockchain-node",
                "æ£€æŸ¥OOM killeræ—¥å¿—ï¼šdmesg | grep -i kill",
            ],
            common_causes: vec![
                CrashCause {
                    cause: "å†…å­˜ä¸è¶³ï¼ˆOOMï¼‰",
                    indicators: vec![
                        "æ—¥å¿—ä¸­å‡ºç° 'Out of memory'",
                        "dmesgä¸­OOM killerè®°å½•",
                        "è¿›ç¨‹RSSæŒç»­å¢é•¿",
                    ],
                    solutions: vec![
                        "å¢åŠ ç³»ç»Ÿå†…å­˜",
                        "å‡å°cacheé…ç½®",
                        "å¯ç”¨swapï¼ˆä¸æ¨èç”Ÿäº§ç¯å¢ƒï¼‰",
                        "æ’æŸ¥å†…å­˜æ³„æ¼",
                    ],
                },
                CrashCause {
                    cause: "æœªå¤„ç†çš„panic",
                    indicators: vec![
                        "å †æ ˆè·Ÿè¸ªæ˜¾ç¤ºpanic",
                        "ç‰¹å®šæ“ä½œè§¦å‘å´©æºƒ",
                    ],
                    solutions: vec![
                        "æ›´æ–°åˆ°æœ€æ–°ç‰ˆæœ¬",
                        "æäº¤bugæŠ¥å‘Š",
                        "æ·»åŠ é”™è¯¯å¤„ç†",
                    ],
                },
                CrashCause {
                    cause: "æ•°æ®åº“æŸå",
                    indicators: vec![
                        "è®¿é—®æ•°æ®åº“æ—¶å´©æºƒ",
                        "checksumé”™è¯¯",
                    ],
                    solutions: vec![
                        "è¿è¡Œæ•°æ®åº“ä¿®å¤å·¥å…·",
                        "ä»å¤‡ä»½æ¢å¤",
                        "é‡æ–°åŒæ­¥",
                    ],
                },
            ],
        }
    }
}

#[derive(Debug)]
pub struct CrashAnalysis {
    data_collection: Vec<&'static str>,
    common_causes: Vec<CrashCause>,
}

#[derive(Debug)]
pub struct CrashCause {
    cause: &'static str,
    indicators: Vec<&'static str>,
    solutions: Vec<&'static str>,
}
```

## 3. å…±è¯†é—®é¢˜

### 3.1 å…±è¯†å¤±è´¥

```rust
/// å…±è¯†å¤±è´¥è¯Šæ–­
pub struct ConsensusTroubleshooting;

impl ConsensusTroubleshooting {
    pub fn diagnose_consensus_failure() -> ConsensusAnalysis {
        ConsensusAnalysis {
            common_scenarios: vec![
                ConsensusScenario {
                    scenario: "æ— æ³•è¾¾æˆå…±è¯†",
                    indicators: vec![
                        "åŒºå—æè®®è¶…æ—¶",
                        "æŠ•ç¥¨ä¸è¶³",
                        "æ—¥å¿—æ˜¾ç¤ºconsensus timeout",
                    ],
                    possible_causes: vec![
                        "éªŒè¯è€…èŠ‚ç‚¹æ•°é‡ä¸è¶³",
                        "ç½‘ç»œåˆ†åŒº",
                        "æ—¶é’Ÿä¸åŒæ­¥",
                        "èŠ‚ç‚¹æ€§èƒ½å·®å¼‚å¤§",
                    ],
                    diagnostic_commands: vec![
                        "æŸ¥çœ‹æ´»è·ƒéªŒè¯è€…ï¼šblockchain-cli validators list",
                        "æ£€æŸ¥ç½‘ç»œè¿é€šæ€§ï¼šblockchain-cli net peers",
                        "æ£€æŸ¥æ—¶é—´åŒæ­¥ï¼štimedatectl status",
                    ],
                    solutions: vec![
                        "ç¡®ä¿2f+1ä¸ªéªŒè¯è€…åœ¨çº¿ï¼ˆfä¸ºæ‹œå åº­èŠ‚ç‚¹æ•°ï¼‰",
                        "ä¿®å¤ç½‘ç»œåˆ†åŒº",
                        "åŒæ­¥æ‰€æœ‰èŠ‚ç‚¹æ—¶é’Ÿï¼ˆNTPï¼‰",
                        "å‡çº§æ…¢èŠ‚ç‚¹ç¡¬ä»¶",
                    ],
                },
                ConsensusScenario {
                    scenario: "å…±è¯†æ€§èƒ½ä¸‹é™",
                    indicators: vec![
                        "å‡ºå—æ—¶é—´å»¶é•¿",
                        "å…±è¯†è½®æ¬¡å¢åŠ ",
                    ],
                    possible_causes: vec![
                        "éªŒè¯è€…è´Ÿè½½é«˜",
                        "ç½‘ç»œå»¶è¿Ÿå¤§",
                        "äº¤æ˜“éªŒè¯æ…¢",
                    ],
                    diagnostic_commands: vec![
                        "ç›‘æ§éªŒè¯è€…èµ„æºï¼štop, iostat",
                        "æµ‹é‡ç½‘ç»œå»¶è¿Ÿï¼šping, mtr",
                        "åˆ†æäº¤æ˜“æ± ï¼šblockchain-cli txpool status",
                    ],
                    solutions: vec![
                        "ä¼˜åŒ–éªŒè¯è€…é…ç½®",
                        "å¢åŠ å¸¦å®½",
                        "ä¼˜åŒ–äº¤æ˜“éªŒè¯é€»è¾‘",
                    ],
                },
            ],
        }
    }
}

#[derive(Debug)]
pub struct ConsensusAnalysis {
    common_scenarios: Vec<ConsensusScenario>,
}

#[derive(Debug)]
pub struct ConsensusScenario {
    scenario: &'static str,
    indicators: Vec<&'static str>,
    possible_causes: Vec<&'static str>,
    diagnostic_commands: Vec<&'static str>,
    solutions: Vec<&'static str>,
}
```

### 3.2 åˆ†å‰é—®é¢˜

```rust
/// åŒºå—é“¾åˆ†å‰é—®é¢˜è¯Šæ–­
pub struct ForkTroubleshooting;

impl ForkTroubleshooting {
    pub fn analyze_fork() -> ForkAnalysis {
        ForkAnalysis {
            fork_types: vec![
                ForkType {
                    name: "çŸ­æš‚åˆ†å‰",
                    description: "æ­£å¸¸ç°è±¡ï¼Œé€šå¸¸è‡ªåŠ¨è§£å†³",
                    duration: "å‡ ä¸ªåŒºå—",
                    handling: vec![
                        "æ— éœ€äººå·¥å¹²é¢„",
                        "ç­‰å¾…ç½‘ç»œè‡ªåŠ¨æ”¶æ•›",
                        "ç›‘æ§æ˜¯å¦æŒç»­",
                    ],
                },
                ForkType {
                    name: "æŒä¹…åˆ†å‰",
                    description: "ç½‘ç»œåˆ†åŒºæˆ–å…±è¯†bugå¯¼è‡´",
                    duration: "æ•°åä¸ªåŒºå—ä»¥ä¸Š",
                    handling: vec![
                        "è¯†åˆ«ä¸»é“¾å’Œå‰¯é“¾",
                        "æ£€æŸ¥ç½‘ç»œåˆ†åŒº",
                        "éªŒè¯å…±è¯†è§„åˆ™",
                        "å¿…è¦æ—¶åè°ƒäººå·¥å¹²é¢„",
                    ],
                },
                ForkType {
                    name: "æ¶æ„åˆ†å‰",
                    description: "51%æ”»å‡»æˆ–é•¿ç¨‹æ”»å‡»",
                    duration: "å¯èƒ½å¾ˆé•¿",
                    handling: vec![
                        "ç«‹å³é€šçŸ¥ç¤¾åŒº",
                        "æš‚åœæœåŠ¡",
                        "åˆ†ææ”»å‡»æ¥æº",
                        "ç¤¾åŒºæŠ•ç¥¨å†³å®šåº”å¯¹ç­–ç•¥",
                    ],
                },
            ],
            detection_methods: vec![
                "ç›‘æ§å­¤å—ç‡",
                "æ¯”è¾ƒä¸åŒèŠ‚ç‚¹çš„é“¾å¤´",
                "åˆ†æå…±è¯†æ—¥å¿—",
                "ä½¿ç”¨åŒºå—æµè§ˆå™¨å¯¹æ¯”",
            ],
            prevention: vec![
                "ç¡®ä¿ç½‘ç»œå¥åº·",
                "åŠæ—¶åŒæ­¥æ—¶é’Ÿ",
                "ä¿æŒè½¯ä»¶ç‰ˆæœ¬ä¸€è‡´",
                "è®¾ç½®æ£€æŸ¥ç‚¹ï¼ˆcheckpointï¼‰",
            ],
        }
    }
}

#[derive(Debug)]
pub struct ForkAnalysis {
    fork_types: Vec<ForkType>,
    detection_methods: Vec<&'static str>,
    prevention: Vec<&'static str>,
}

#[derive(Debug)]
pub struct ForkType {
    name: &'static str,
    description: &'static str,
    duration: &'static str,
    handling: Vec<&'static str>,
}
```

### 3.3 ç½‘ç»œåˆ†åŒº

```rust
/// ç½‘ç»œåˆ†åŒºé—®é¢˜è¯Šæ–­
pub struct NetworkPartitionTroubleshooting;

impl NetworkPartitionTroubleshooting {
    pub fn diagnose_partition() -> PartitionAnalysis {
        PartitionAnalysis {
            detection: vec![
                "èŠ‚ç‚¹æ— æ³•è¿æ¥åˆ°éƒ¨åˆ†å¯¹ç­‰èŠ‚ç‚¹",
                "å…±è¯†è¶…æ—¶é¢‘ç¹",
                "åŒºå—é«˜åº¦å·®å¼‚å¤§",
                "ä¸åŒèŠ‚ç‚¹æŠ¥å‘Šä¸åŒçš„é“¾å¤´",
            ],
            diagnosis_steps: vec![
                "1. ç»˜åˆ¶ç½‘ç»œæ‹“æ‰‘å›¾",
                "2. æµ‹è¯•èŠ‚ç‚¹é—´è¿é€šæ€§ï¼ˆping, tracerouteï¼‰",
                "3. æ£€æŸ¥é˜²ç«å¢™/å®‰å…¨ç»„è§„åˆ™",
                "4. æŸ¥çœ‹BGPè·¯ç”±ï¼ˆå¦‚æœè·¨ISPï¼‰",
                "5. åˆ†æç½‘ç»œæ—¥å¿—",
            ],
            resolution: vec![
                "ä¿®å¤ç½‘ç»œè¿æ¥",
                "è°ƒæ•´é˜²ç«å¢™è§„åˆ™",
                "æ·»åŠ ä¸­ç»§èŠ‚ç‚¹",
                "ç­‰å¾…ç½‘ç»œè‡ªæ„ˆ",
                "å¿…è¦æ—¶æ‰‹åŠ¨åè°ƒ",
            ],
            prevention: vec![
                "å¤šåŒºåŸŸéƒ¨ç½²",
                "å†—ä½™ç½‘ç»œé“¾è·¯",
                "ç›‘æ§ç½‘ç»œå¥åº·",
                "å®šæœŸæ¼”ç»ƒæ•…éšœæ¢å¤",
            ],
        }
    }
}

#[derive(Debug)]
pub struct PartitionAnalysis {
    detection: Vec<&'static str>,
    diagnosis_steps: Vec<&'static str>,
    resolution: Vec<&'static str>,
    prevention: Vec<&'static str>,
}
```

## 4. äº¤æ˜“é—®é¢˜

### 4.1 äº¤æ˜“pending

```rust
/// äº¤æ˜“pendingé—®é¢˜è¯Šæ–­
pub struct TransactionPendingTroubleshooting;

impl TransactionPendingTroubleshooting {
    pub fn analyze_pending_tx() -> PendingTxAnalysis {
        PendingTxAnalysis {
            common_causes: vec![
                PendingCause {
                    cause: "Gas priceè¿‡ä½",
                    how_to_check: "æ¯”è¾ƒäº¤æ˜“gas priceä¸å½“å‰ç½‘ç»œgas price",
                    solution: vec![
                        "æé«˜gas priceé‡æ–°å‘é€",
                        "ä½¿ç”¨gas priceé¢„è¨€æœº",
                        "ç­‰å¾…ç½‘ç»œæ‹¥å µç¼“è§£",
                    ],
                },
                PendingCause {
                    cause: "Nonceé”™è¯¯",
                    how_to_check: "æ£€æŸ¥è´¦æˆ·nonceä¸äº¤æ˜“nonce",
                    solution: vec![
                        "ä½¿ç”¨æ­£ç¡®çš„nonce",
                        "ç­‰å¾…å‰åºäº¤æ˜“ç¡®è®¤",
                        "å–æ¶ˆå¡ä½çš„äº¤æ˜“ï¼ˆå‘é€nonceç›¸åŒã€gas priceæ›´é«˜çš„äº¤æ˜“ï¼‰",
                    ],
                },
                PendingCause {
                    cause: "äº¤æ˜“æ± æ»¡",
                    how_to_check: "æŸ¥è¯¢èŠ‚ç‚¹äº¤æ˜“æ± çŠ¶æ€",
                    solution: vec![
                        "ç­‰å¾…äº¤æ˜“æ± å¤„ç†",
                        "æé«˜gas priceä»¥ä¼˜å…ˆå¤„ç†",
                        "å‘å…¶ä»–èŠ‚ç‚¹æäº¤",
                    ],
                },
                PendingCause {
                    cause: "ä½™é¢ä¸è¶³",
                    how_to_check: "æŸ¥è¯¢è´¦æˆ·ä½™é¢æ˜¯å¦ >= value + gas",
                    solution: vec![
                        "å……å€¼è´¦æˆ·",
                        "é™ä½äº¤æ˜“é‡‘é¢",
                        "é™ä½gas limit",
                    ],
                },
            ],
            æŸ¥è¯¢å‘½ä»¤: vec![
                "eth_getTransactionByHash - è·å–äº¤æ˜“è¯¦æƒ…",
                "eth_getTransactionReceipt - æŸ¥çœ‹æ˜¯å¦å·²ç¡®è®¤",
                "txpool_status - æŸ¥çœ‹äº¤æ˜“æ± çŠ¶æ€",
                "eth_gasPrice - è·å–å½“å‰gas price",
                "eth_getTransactionCount - è·å–è´¦æˆ·nonce",
            ],
        }
    }
}

#[derive(Debug)]
pub struct PendingTxAnalysis {
    common_causes: Vec<PendingCause>,
    æŸ¥è¯¢å‘½ä»¤: Vec<&'static str>,
}

#[derive(Debug)]
pub struct PendingCause {
    cause: &'static str,
    how_to_check: &'static str,
    solution: Vec<&'static str>,
}
```

### 4.2 äº¤æ˜“å¤±è´¥

```rust
/// äº¤æ˜“å¤±è´¥é—®é¢˜è¯Šæ–­
pub struct TransactionFailureTroubleshooting;

impl TransactionFailureTroubleshooting {
    pub fn common_failures() -> Vec<TxFailure> {
        vec![
            TxFailure {
                error_message: "out of gas",
                meaning: "Gas limitä¸è¶³",
                diagnosis: "æ£€æŸ¥äº¤æ˜“çš„gas used vs gas limit",
                solution: vec![
                    "å¢åŠ gas limit",
                    "ä¼˜åŒ–åˆçº¦ä»£ç å‡å°‘gasæ¶ˆè€—",
                    "åˆ†æ‰¹å¤„ç†æ•°æ®",
                ],
            },
            TxFailure {
                error_message: "revert",
                meaning: "æ™ºèƒ½åˆçº¦æ‰§è¡Œè¢«å›æ»š",
                diagnosis: "æŸ¥çœ‹revertåŸå› ï¼ˆå¦‚æœæœ‰ï¼‰",
                solution: vec![
                    "æ£€æŸ¥åˆçº¦require/assertæ¡ä»¶",
                    "éªŒè¯è¾“å…¥å‚æ•°",
                    "æ£€æŸ¥åˆçº¦çŠ¶æ€",
                ],
            },
            TxFailure {
                error_message: "invalid signature",
                meaning: "ç­¾åæ— æ•ˆ",
                diagnosis: "éªŒè¯ç§é’¥ã€ç­¾åç®—æ³•",
                solution: vec![
                    "ç¡®è®¤ä½¿ç”¨æ­£ç¡®ç§é’¥",
                    "æ£€æŸ¥ç­¾åæ ¼å¼ï¼ˆv,r,sï¼‰",
                    "éªŒè¯chain ID",
                ],
            },
            TxFailure {
                error_message: "nonce too low",
                meaning: "Nonceå·²è¢«ä½¿ç”¨",
                diagnosis: "å¯¹æ¯”äº¤æ˜“nonceå’Œè´¦æˆ·current nonce",
                solution: vec![
                    "ä½¿ç”¨æ›´æ–°çš„nonce",
                    "ç­‰å¾…pendingäº¤æ˜“ç¡®è®¤",
                ],
            },
        ]
    }
}

#[derive(Debug)]
pub struct TxFailure {
    error_message: &'static str,
    meaning: &'static str,
    diagnosis: &'static str,
    solution: Vec<&'static str>,
}
```

### 4.3 Gasä¼°ç®—é”™è¯¯

```rust
/// Gasä¼°ç®—é—®é¢˜
pub struct GasEstimationTroubleshooting;

impl GasEstimationTroubleshooting {
    pub fn common_issues() -> Vec<GasIssue> {
        vec![
            GasIssue {
                issue: "ä¼°ç®—å¤±è´¥",
                causes: vec![
                    "åˆçº¦è°ƒç”¨ä¼šrevert",
                    "çŠ¶æ€ä¾èµ–å¯¼è‡´æ¨¡æ‹Ÿå¤±è´¥",
                ],
                solutions: vec![
                    "æ‰‹åŠ¨è®¾ç½®gas limit",
                    "æ£€æŸ¥åˆçº¦é€»è¾‘",
                    "ä½¿ç”¨æ›´é«˜çš„gas limitï¼ˆ1.5xä¼°ç®—å€¼ï¼‰",
                ],
            },
            GasIssue {
                issue: "ä¼°ç®—ä¸å‡†ç¡®",
                causes: vec![
                    "çŠ¶æ€å˜åŒ–å½±å“gasæ¶ˆè€—",
                    "ä¼°ç®—æ—¶é—´å’Œæ‰§è¡Œæ—¶é—´ä¸åŒ",
                ],
                solutions: vec![
                    "æ·»åŠ å®‰å…¨ç³»æ•°ï¼ˆ20-50%ï¼‰",
                    "ä½¿ç”¨å†å²æ•°æ®æ ¡å‡†",
                ],
            },
        ]
    }
}

#[derive(Debug)]
pub struct GasIssue {
    issue: &'static str,
    causes: Vec<&'static str>,
    solutions: Vec<&'static str>,
}
```

## 5. æ™ºèƒ½åˆçº¦é—®é¢˜

### 5.1 åˆçº¦éƒ¨ç½²å¤±è´¥

```rust
/// åˆçº¦éƒ¨ç½²é—®é¢˜è¯Šæ–­
pub struct ContractDeploymentTroubleshooting;

impl ContractDeploymentTroubleshooting {
    pub fn deployment_issues() -> Vec<DeploymentIssue> {
        vec![
            DeploymentIssue {
                error: "Contract code size exceeds maximum",
                explanation: "åˆçº¦å­—èŠ‚ç è¶…è¿‡24KBé™åˆ¶ï¼ˆEIP-170ï¼‰",
                solutions: vec![
                    "æ‹†åˆ†åˆçº¦ä¸ºå¤šä¸ªå­åˆçº¦",
                    "ä½¿ç”¨åº“ï¼ˆlibraryï¼‰",
                    "å¯ç”¨ä¼˜åŒ–å™¨ï¼šsolc --optimize",
                    "ç§»é™¤æœªä½¿ç”¨çš„ä»£ç ",
                ],
            },
            DeploymentIssue {
                error: "Constructor revert",
                explanation: "æ„é€ å‡½æ•°æ‰§è¡Œå¤±è´¥",
                solutions: vec![
                    "æ£€æŸ¥æ„é€ å‡½æ•°å‚æ•°",
                    "éªŒè¯åˆå§‹åŒ–é€»è¾‘",
                    "ç¡®ä¿ä¾èµ–åˆçº¦å·²éƒ¨ç½²",
                ],
            },
            DeploymentIssue {
                error: "Insufficient funds",
                explanation: "éƒ¨ç½²è´¦æˆ·ä½™é¢ä¸è¶³",
                solutions: vec![
                    "å……å€¼éƒ¨ç½²è´¦æˆ·",
                    "é™ä½gas price",
                    "ä¼˜åŒ–åˆçº¦å‡å°‘éƒ¨ç½²æˆæœ¬",
                ],
            },
        ]
    }
}

#[derive(Debug)]
pub struct DeploymentIssue {
    error: &'static str,
    explanation: &'static str,
    solutions: Vec<&'static str>,
}
```

### 5.2 åˆçº¦è°ƒç”¨é”™è¯¯

```rust
/// åˆçº¦è°ƒç”¨é—®é¢˜è¯Šæ–­
pub struct ContractCallTroubleshooting;

impl ContractCallTroubleshooting {
    pub fn call_errors() -> Vec<CallError> {
        vec![
            CallError {
                error: "execution reverted",
                possible_reasons: vec![
                    "requireæ¡ä»¶ä¸æ»¡è¶³",
                    "assertå¤±è´¥",
                    "è°ƒç”¨ä¸å­˜åœ¨çš„å‡½æ•°",
                    "è®¿é—®æƒé™ä¸è¶³",
                ],
                debugging: vec![
                    "ä½¿ç”¨Hardhat/Foundryè°ƒè¯•",
                    "æ·»åŠ äº‹ä»¶æ—¥å¿—",
                    "ä½¿ç”¨Tenderlyæ¨¡æ‹Ÿ",
                    "æŸ¥çœ‹revertåŸå› å­—ç¬¦ä¸²",
                ],
            },
            CallError {
                error: "invalid opcode",
                possible_reasons: vec![
                    "è®¿é—®æœªåˆå§‹åŒ–çš„å˜é‡",
                    "é™¤ä»¥é›¶",
                    "æ•°ç»„è¶Šç•Œï¼ˆæ—§ç‰ˆæœ¬ï¼‰",
                ],
                debugging: vec![
                    "æ£€æŸ¥å˜é‡åˆå§‹åŒ–",
                    "æ·»åŠ è¾¹ç•Œæ£€æŸ¥",
                    "ä½¿ç”¨SafeMath",
                ],
            },
        ]
    }
}

#[derive(Debug)]
pub struct CallError {
    error: &'static str,
    possible_reasons: Vec<&'static str>,
    debugging: Vec<&'static str>,
}
```

### 5.3 åˆçº¦å®‰å…¨æ¼æ´

å·²åœ¨å®‰å…¨æœ€ä½³å®è·µæ–‡æ¡£ä¸­è¯¦ç»†è¯´æ˜ã€‚

## 6. ç½‘ç»œé—®é¢˜

### 6.1 P2Pè¿æ¥é—®é¢˜

```rust
/// P2Pç½‘ç»œè¿æ¥é—®é¢˜è¯Šæ–­
pub struct P2PConnectionTroubleshooting;

impl P2PConnectionTroubleshooting {
    pub fn connection_issues() -> Vec<P2PIs sue> {
        vec![
            P2PIssue {
                symptom: "æ— æ³•è¿æ¥åˆ°ä»»ä½•peer",
                checks: vec![
                    "é˜²ç«å¢™æ˜¯å¦é˜»æ­¢P2Pç«¯å£",
                    "NATç©¿é€æ˜¯å¦é…ç½®",
                    "bootnodeåœ°å€æ˜¯å¦æ­£ç¡®",
                    "ç½‘ç»œæ˜¯å¦å¯è¾¾",
                ],
                solutions: vec![
                    "å¼€æ”¾P2Pç«¯å£ï¼ˆé»˜è®¤30303ï¼‰",
                    "é…ç½®ç«¯å£è½¬å‘/UPnP",
                    "ä½¿ç”¨å…¬ç½‘IPçš„bootnode",
                    "æ£€æŸ¥ç½‘ç»œè¿é€šæ€§",
                ],
            },
            P2PIssue {
                symptom: "peeræ•°é‡å°‘",
                checks: vec![
                    "maxpeersé…ç½®",
                    "ç½‘ç»œæ‹“æ‰‘",
                    "èŠ‚ç‚¹å£°èª‰",
                ],
                solutions: vec![
                    "å¢åŠ maxpeerså€¼",
                    "æ·»åŠ é™æ€èŠ‚ç‚¹",
                    "æ”¹å–„èŠ‚ç‚¹ç½‘ç»œç¯å¢ƒ",
                ],
            },
        ]
    }
}

#[derive(Debug)]
pub struct P2PIssue {
    symptom: &'static str,
    checks: Vec<&'static str>,
    solutions: Vec<&'static str>,
}
```

### 6.2 ç½‘ç»œå»¶è¿Ÿé«˜

```rust
/// ç½‘ç»œå»¶è¿Ÿé—®é¢˜è¯Šæ–­
pub struct NetworkLatencyTroubleshooting;

impl NetworkLatencyTroubleshooting {
    pub fn diagnose_latency() -> LatencyAnalysis {
        LatencyAnalysis {
            measurement_tools: vec![
                "ping - ICMPå»¶è¿Ÿ",
                "mtr - è·¯ç”±è·Ÿè¸ª",
                "iperf3 - å¸¦å®½æµ‹è¯•",
                "blockchain-cli net latency - åº”ç”¨å±‚å»¶è¿Ÿ",
            ],
            common_causes: vec![
                "åœ°ç†è·ç¦»è¿œ",
                "ç½‘ç»œæ‹¥å¡",
                "è·¯ç”±é—®é¢˜",
                "ISPé™é€Ÿ",
            ],
            solutions: vec![
                "é€‰æ‹©åœ°ç†ä½ç½®è¿‘çš„peer",
                "ä½¿ç”¨CDN/ä¸“çº¿",
                "ä¼˜åŒ–è·¯ç”±",
                "å¢åŠ å¸¦å®½",
            ],
        }
    }
}

#[derive(Debug)]
pub struct LatencyAnalysis {
    measurement_tools: Vec<&'static str>,
    common_causes: Vec<&'static str>,
    solutions: Vec<&'static str>,
}
```

### 6.3 DDoSæ”»å‡»

```rust
/// DDoSæ”»å‡»é˜²æŠ¤
pub struct DDoSTroubleshooting;

impl DDoSTroubleshooting {
    pub fn detection_and_mitigation() -> DDoSResponse {
        DDoSResponse {
            detection_indicators: vec![
                "å¼‚å¸¸é«˜çš„è¿æ¥è¯·æ±‚",
                "CPU/å¸¦å®½çªç„¶é£™å‡",
                "å¤§é‡æ¥è‡ªåŒä¸€IP/ç½‘æ®µçš„è¯·æ±‚",
                "æœåŠ¡å“åº”ç¼“æ…¢æˆ–è¶…æ—¶",
            ],
            immediate_actions: vec![
                "å¯ç”¨é€Ÿç‡é™åˆ¶",
                "å°ç¦æ¶æ„IP",
                "å¯ç”¨DDoSé˜²æŠ¤æœåŠ¡ï¼ˆCloudflareç­‰ï¼‰",
                "é™åˆ¶æ–°è¿æ¥é€Ÿç‡",
            ],
            long_term_solutions: vec![
                "éƒ¨ç½²DDoSé˜²æŠ¤ç³»ç»Ÿ",
                "ä½¿ç”¨è´Ÿè½½å‡è¡¡",
                "å®æ–½IPç™½åå•æœºåˆ¶",
                "å¢åŠ åŸºç¡€è®¾æ–½å†—ä½™",
            ],
        }
    }
}

#[derive(Debug)]
pub struct DDoSResponse {
    detection_indicators: Vec<&'static str>,
    immediate_actions: Vec<&'static str>,
    long_term_solutions: Vec<&'static str>,
}
```

## 7. å­˜å‚¨é—®é¢˜

### 7.1 æ•°æ®åº“æŸå

```rust
/// æ•°æ®åº“æŸåé—®é¢˜
pub struct DatabaseCorruptionTroubleshooting;

impl DatabaseCorruptionTroubleshooting {
    pub fn handle_corruption() -> CorruptionHandling {
        CorruptionHandling {
            detection: vec![
                "å¯åŠ¨æ—¶æŠ¥checksum error",
                "æŸ¥è¯¢æ—¶å´©æºƒ",
                "æ•°æ®ä¸ä¸€è‡´",
            ],
            recovery_steps: vec![
                "1. åœæ­¢èŠ‚ç‚¹",
                "2. å¤‡ä»½å½“å‰æ•°æ®ï¼ˆå³ä½¿å·²æŸåï¼‰",
                "3. å°è¯•æ•°æ®åº“ä¿®å¤å·¥å…·",
                "4. å¦‚æœä¿®å¤å¤±è´¥ï¼Œä»å¤‡ä»½æ¢å¤",
                "5. æœ€åæ‰‹æ®µï¼šåˆ é™¤æ•°æ®åº“é‡æ–°åŒæ­¥",
            ],
            prevention: vec![
                "å®šæœŸå¤‡ä»½",
                "ä½¿ç”¨RAIDç£ç›˜é˜µåˆ—",
                "å¯ç”¨æ•°æ®åº“æ ¡éªŒ",
                "ä¼˜é›…å…³é—­èŠ‚ç‚¹ï¼ˆé¿å…å¼ºæ€ï¼‰",
            ],
        }
    }
}

#[derive(Debug)]
pub struct CorruptionHandling {
    detection: Vec<&'static str>,
    recovery_steps: Vec<&'static str>,
    prevention: Vec<&'static str>,
}
```

### 7.2 ç£ç›˜ç©ºé—´ä¸è¶³

```rust
/// ç£ç›˜ç©ºé—´é—®é¢˜
pub struct DiskSpaceTroubleshooting;

impl DiskSpaceTroubleshooting {
    pub fn manage_disk_space() -> DiskManagement {
        DiskManagement {
            monitoring: vec![
                "df -h - æŸ¥çœ‹ç£ç›˜ä½¿ç”¨",
                "du -sh /var/lib/blockchain/* - æŸ¥çœ‹å„ç›®å½•å¤§å°",
                "è®¾ç½®ç›‘æ§å‘Šè­¦ï¼ˆ<20%å‰©ä½™ç©ºé—´ï¼‰",
            ],
            immediate_solutions: vec![
                "åˆ é™¤æ—§æ—¥å¿—æ–‡ä»¶",
                "æ¸…ç†ä¸´æ—¶æ–‡ä»¶",
                "å‹ç¼©å½’æ¡£æ•°æ®",
            ],
            long_term_solutions: vec![
                "å¢åŠ ç£ç›˜å®¹é‡",
                "å¯ç”¨pruningæ¨¡å¼",
                "ä½¿ç”¨å¤–éƒ¨å­˜å‚¨",
                "å®æ–½æ•°æ®ç”Ÿå‘½å‘¨æœŸç®¡ç†",
            ],
        }
    }
}

#[derive(Debug)]
pub struct DiskManagement {
    monitoring: Vec<&'static str>,
    immediate_solutions: Vec<&'static str>,
    long_term_solutions: Vec<&'static str>,
}
```

### 7.3 æ•°æ®åŒæ­¥æ…¢

å·²åœ¨èŠ‚ç‚¹åŒæ­¥é—®é¢˜ä¸­è¯´æ˜ã€‚

## 8. æ€§èƒ½é—®é¢˜

### 8.1 TPSä½

å·²åœ¨æ€§èƒ½ä¼˜åŒ–æ–‡æ¡£ä¸­è¯¦ç»†è¯´æ˜ã€‚

### 8.2 å†…å­˜æ³„æ¼

```rust
/// å†…å­˜æ³„æ¼è¯Šæ–­
pub struct MemoryLeakTroubleshooting;

impl MemoryLeakTroubleshooting {
    pub fn diagnose_memory_leak() -> MemoryLeakAnalysis {
        MemoryLeakAnalysis {
            detection: vec![
                "å†…å­˜ä½¿ç”¨æŒç»­å¢é•¿",
                "æœ€ç»ˆå¯¼è‡´OOM",
                "GCé¢‘ç¹ä½†å†…å­˜ä¸é‡Šæ”¾",
            ],
            profiling_tools: vec![
                "valgrind - C/C++å†…å­˜åˆ†æ",
                "pprof - Goå†…å­˜åˆ†æ",
                "heaptrack - å †å†…å­˜åˆ†æ",
                "/proc/{pid}/smaps - å†…å­˜æ˜ å°„",
            ],
            common_causes: vec![
                "æœªå…³é—­çš„è¿æ¥/æ–‡ä»¶å¥æŸ„",
                "ç¼“å­˜æ— ç•Œå¢é•¿",
                "å¾ªç¯å¼•ç”¨",
                "äº‹ä»¶ç›‘å¬å™¨æœªç§»é™¤",
            ],
            solutions: vec![
                "ä¿®å¤ä»£ç æ³„æ¼ç‚¹",
                "è®¾ç½®ç¼“å­˜ä¸Šé™",
                "ä½¿ç”¨å¼±å¼•ç”¨",
                "å®šæœŸé‡å¯ï¼ˆä¸´æ—¶æ–¹æ¡ˆï¼‰",
            ],
        }
    }
}

#[derive(Debug)]
pub struct MemoryLeakAnalysis {
    detection: Vec<&'static str>,
    profiling_tools: Vec<&'static str>,
    common_causes: Vec<&'static str>,
    solutions: Vec<&'static str>,
}
```

### 8.3 CPUå ç”¨é«˜

```rust
/// CPUå ç”¨é«˜é—®é¢˜è¯Šæ–­
pub struct HighCPUTroubleshooting;

impl HighCPUTroubleshooting {
    pub fn analyze_high_cpu() -> CPUAnalysis {
        CPUAnalysis {
            profiling: vec![
                "top/htop - å®æ—¶ç›‘æ§",
                "perf top - çƒ­ç‚¹å‡½æ•°",
                "flamegraph - ç«ç„°å›¾åˆ†æ",
                "pprof - Go CPU profile",
            ],
            common_causes: vec![
                "å¯†é›†çš„åŠ å¯†è¿ç®—",
                "åŒºå—éªŒè¯",
                "P2Pæ¶ˆæ¯å¤„ç†",
                "æ•°æ®åº“æŸ¥è¯¢",
                "æ— é™å¾ªç¯/æ­»é”",
            ],
            optimization: vec![
                "å¹¶è¡ŒåŒ–å¤„ç†",
                "ç¼“å­˜è®¡ç®—ç»“æœ",
                "ä¼˜åŒ–ç®—æ³•å¤æ‚åº¦",
                "ä½¿ç”¨ç¡¬ä»¶åŠ é€Ÿ",
            ],
        }
    }
}

#[derive(Debug)]
pub struct CPUAnalysis {
    profiling: Vec<&'static str>,
    common_causes: Vec<&'static str>,
    optimization: Vec<&'static str>,
}
```

## 9. å®‰å…¨é—®é¢˜

### 9.1 ç§é’¥æ³„éœ²

```rust
/// ç§é’¥æ³„éœ²åº”æ€¥å“åº”
pub struct PrivateKeyCompromise;

impl PrivateKeyCompromise {
    pub fn incident_response() -> IncidentResponse {
        IncidentResponse {
            immediate_actions: vec![
                "1. ç«‹å³åœæ­¢ä½¿ç”¨è¯¥å¯†é’¥",
                "2. è½¬ç§»èµ„äº§åˆ°æ–°åœ°å€",
                "3. æ’¤é”€ç›¸å…³æƒé™",
                "4. é€šçŸ¥ç›¸å…³æ–¹",
            ],
            investigation: vec![
                "ç¡®å®šæ³„éœ²èŒƒå›´",
                "è¿½è¸ªæ³„éœ²æ¥æº",
                "è¯„ä¼°æŸå¤±",
                "è®°å½•äº‹ä»¶",
            ],
            remediation: vec![
                "ç”Ÿæˆæ–°å¯†é’¥å¯¹",
                "æ›´æ–°æ‰€æœ‰ç›¸å…³é…ç½®",
                "åŠ å¼ºå¯†é’¥ç®¡ç†",
                "å®æ–½å¤šç­¾æœºåˆ¶",
            ],
            prevention: vec![
                "ä½¿ç”¨ç¡¬ä»¶é’±åŒ…/HSM",
                "å¯†é’¥åŠ å¯†å­˜å‚¨",
                "æœ€å°æƒé™åŸåˆ™",
                "å®šæœŸè½®æ¢å¯†é’¥",
            ],
        }
    }
}

#[derive(Debug)]
pub struct IncidentResponse {
    immediate_actions: Vec<&'static str>,
    investigation: Vec<&'static str>,
    remediation: Vec<&'static str>,
    prevention: Vec<&'static str>,
}
```

### 9.2 51%æ”»å‡»

```rust
/// 51%æ”»å‡»æ£€æµ‹ä¸åº”å¯¹
pub struct FiftyOnePercentAttack;

impl FiftyOnePercentAttack {
    pub fn detection_and_response() -> AttackResponse {
        AttackResponse {
            detection_indicators: vec![
                "å•ä¸€çŸ¿å·¥/çŸ¿æ± ç®—åŠ›è¶…è¿‡51%",
                "å‡ºç°æ·±åº¦åŒºå—é‡ç»„",
                "åŒèŠ±äº¤æ˜“",
                "å®¡æŸ¥äº¤æ˜“",
            ],
            immediate_response: vec![
                "æš‚åœå¤§é¢äº¤æ˜“",
                "å¢åŠ ç¡®è®¤æ•°è¦æ±‚",
                "é€šçŸ¥ç¤¾åŒºå’Œäº¤æ˜“æ‰€",
                "ç›‘æ§æ”»å‡»è€…è¡Œä¸º",
            ],
            long_term_solutions: vec![
                "åˆ‡æ¢å…±è¯†ç®—æ³•ï¼ˆPoSï¼‰",
                "å¢åŠ ç½‘ç»œå“ˆå¸Œç‡",
                "å®æ–½æ£€æŸ¥ç‚¹æœºåˆ¶",
                "è”ç›ŸæŠµåˆ¶æ”»å‡»è€…",
            ],
        }
    }
}

#[derive(Debug)]
pub struct AttackResponse {
    detection_indicators: Vec<&'static str>,
    immediate_response: Vec<&'static str>,
    long_term_solutions: Vec<&'static str>,
}
```

### 9.3 å¥³å·«æ”»å‡»

```rust
/// å¥³å·«æ”»å‡»é˜²å¾¡
pub struct SybilAttackDefense;

impl SybilAttackDefense {
    pub fn defense_mechanisms() -> Vec<DefenseMechanism> {
        vec![
            DefenseMechanism {
                mechanism: "èµ„æºè¯æ˜ï¼ˆPoW/PoSï¼‰",
                description: "åˆ›å»ºèº«ä»½éœ€è¦æˆæœ¬",
                effectiveness: "é«˜",
            },
            DefenseMechanism {
                mechanism: "å£°èª‰ç³»ç»Ÿ",
                description: "åŸºäºå†å²è¡Œä¸ºè¯„åˆ†",
                effectiveness: "ä¸­",
            },
            DefenseMechanism {
                mechanism: "èº«ä»½éªŒè¯",
                description: "KYC/å®åè®¤è¯",
                effectiveness: "é«˜ï¼ˆä½†ç‰ºç‰²åŒ¿åæ€§ï¼‰",
            },
            DefenseMechanism {
                mechanism: "ç¤¾äº¤å›¾è°±",
                description: "åŸºäºä¿¡ä»»ç½‘ç»œ",
                effectiveness: "ä¸­",
            },
        ]
    }
}

#[derive(Debug)]
pub struct DefenseMechanism {
    mechanism: &'static str,
    description: &'static str,
    effectiveness: &'static str,
}
```

## 10. å·¥å…·ä¸æœ€ä½³å®è·µ

### 10.1 è¯Šæ–­å·¥å…·

```rust
/// è¯Šæ–­å·¥å…·é›†
pub struct DiagnosticToolkit;

impl DiagnosticToolkit {
    pub fn essential_tools() -> Vec<DiagnosticTool> {
        vec![
            DiagnosticTool {
                category: "æ—¥å¿—åˆ†æ",
                tools: vec![
                    ("tail", "å®æ—¶æŸ¥çœ‹æ—¥å¿—"),
                    ("grep", "æœç´¢æ—¥å¿—å†…å®¹"),
                    ("awk/sed", "æ—¥å¿—å¤„ç†"),
                    ("logrotate", "æ—¥å¿—è½®è½¬"),
                ],
            },
            DiagnosticTool {
                category: "ç½‘ç»œè¯Šæ–­",
                tools: vec![
                    ("ping", "æµ‹è¯•è¿é€šæ€§"),
                    ("traceroute/mtr", "è·¯ç”±è·Ÿè¸ª"),
                    ("netstat", "ç½‘ç»œè¿æ¥"),
                    ("tcpdump", "æŠ“åŒ…åˆ†æ"),
                    ("iftop", "å®æ—¶æµé‡ç›‘æ§"),
                ],
            },
            DiagnosticTool {
                category: "æ€§èƒ½åˆ†æ",
                tools: vec![
                    ("top/htop", "è¿›ç¨‹ç›‘æ§"),
                    ("iostat", "I/Oç»Ÿè®¡"),
                    ("vmstat", "è™šæ‹Ÿå†…å­˜"),
                    ("perf", "æ€§èƒ½åˆ†æ"),
                    ("flamegraph", "ç«ç„°å›¾"),
                ],
            },
            DiagnosticTool {
                category: "åŒºå—é“¾ä¸“ç”¨",
                tools: vec![
                    ("blockchain-cli", "èŠ‚ç‚¹ç®¡ç†"),
                    ("etherscan", "åŒºå—æµè§ˆå™¨"),
                    ("Tenderly", "äº¤æ˜“æ¨¡æ‹Ÿ"),
                    ("Hardhat", "æœ¬åœ°æµ‹è¯•"),
                ],
            },
        ]
    }
}

#[derive(Debug)]
pub struct DiagnosticTool {
    category: &'static str,
    tools: Vec<(&'static str, &'static str)>,
}
```

### 10.2 ç›‘æ§å·¥å…·

```rust
/// ç›‘æ§å·¥å…·æ¨è
pub struct MonitoringTools;

impl MonitoringTools {
    pub fn recommended_stack() -> MonitoringStack {
        MonitoringStack {
            metrics_collection: vec![
                ("Prometheus", "æŒ‡æ ‡é‡‡é›†"),
                ("Node Exporter", "ç³»ç»ŸæŒ‡æ ‡"),
                ("Process Exporter", "è¿›ç¨‹æŒ‡æ ‡"),
            ],
            visualization: vec![
                ("Grafana", "æŒ‡æ ‡å¯è§†åŒ–"),
                ("Kibana", "æ—¥å¿—å¯è§†åŒ–"),
            ],
            alerting: vec![
                ("Alertmanager", "å‘Šè­¦è·¯ç”±"),
                ("PagerDuty", "å€¼ç­é€šçŸ¥"),
            ],
            log_management: vec![
                ("ELK Stack", "æ—¥å¿—èšåˆ"),
                ("Loki", "è½»é‡çº§æ—¥å¿—"),
            ],
            apm: vec![
                ("Jaeger", "åˆ†å¸ƒå¼è¿½è¸ª"),
                ("Zipkin", "è¿½è¸ªåˆ†æ"),
            ],
        }
    }
}

#[derive(Debug)]
pub struct MonitoringStack {
    metrics_collection: Vec<(&'static str, &'static str)>,
    visualization: Vec<(&'static str, &'static str)>,
    alerting: Vec<(&'static str, &'static str)>,
    log_management: Vec<(&'static str, &'static str)>,
    apm: Vec<(&'static str, &'static str)>,
}
```

### 10.3 æœ€ä½³å®è·µ

```rust
/// æ•…éšœæ’é™¤æœ€ä½³å®è·µ
pub struct TroubleshootingBestPractices;

impl TroubleshootingBestPractices {
    pub fn best_practices() -> Vec<BestPractice> {
        vec![
            BestPractice {
                category: "é¢„é˜²",
                practices: vec![
                    "å®šæœŸå¤‡ä»½æ•°æ®",
                    "ç›‘æ§å…³é”®æŒ‡æ ‡",
                    "ä¿æŒè½¯ä»¶æ›´æ–°",
                    "æ–‡æ¡£åŒ–é…ç½®",
                    "å®šæœŸæ¼”ç»ƒæ•…éšœæ¢å¤",
                ],
            },
            BestPractice {
                category: "è¯Šæ–­",
                practices: vec![
                    "ç³»ç»ŸåŒ–è¯Šæ–­æµç¨‹",
                    "ä¿ç•™ç°åœºï¼ˆæ—¥å¿—ã€é…ç½®ï¼‰",
                    "é€æ­¥æ’é™¤æ³•",
                    "è®°å½•è¯Šæ–­è¿‡ç¨‹",
                    "å‚è€ƒçŸ¥è¯†åº“",
                ],
            },
            BestPractice {
                category: "æ¢å¤",
                practices: vec![
                    "å…ˆå¤‡ä»½å†æ“ä½œ",
                    "å‡†å¤‡å›æ»šè®¡åˆ’",
                    "å°æ­¥å¿«è·‘",
                    "éªŒè¯ä¿®å¤æ•ˆæœ",
                    "æ›´æ–°æ–‡æ¡£",
                ],
            },
            BestPractice {
                category: "äº‹å",
                practices: vec![
                    "æ ¹å› åˆ†æï¼ˆRoot Cause Analysisï¼‰",
                    "æ€»ç»“ç»éªŒæ•™è®­",
                    "æ”¹è¿›é¢„é˜²æªæ–½",
                    "æ›´æ–°çŸ¥è¯†åº“",
                    "å›¢é˜Ÿåˆ†äº«",
                ],
            },
        ]
    }
    
    /// æ•…éšœæ’é™¤æ£€æŸ¥æ¸…å•æ¨¡æ¿
    pub fn checklist_template() -> String {
        r#"
æ•…éšœæ’é™¤æ£€æŸ¥æ¸…å•
==================

é—®é¢˜æè¿°ï¼š
- ç—‡çŠ¶ï¼š
- å‘ç”Ÿæ—¶é—´ï¼š
- å½±å“èŒƒå›´ï¼š
- é”™è¯¯ä¿¡æ¯ï¼š

è¯Šæ–­æ­¥éª¤ï¼š
â–¡ æ”¶é›†æ—¥å¿—
â–¡ æ£€æŸ¥ç³»ç»Ÿèµ„æº
â–¡ éªŒè¯ç½‘ç»œè¿æ¥
â–¡ æŸ¥çœ‹é…ç½®æ–‡ä»¶
â–¡ å¯¹æ¯”æ­£å¸¸çŠ¶æ€

å·²å°è¯•æ–¹æ¡ˆï¼š
1. 
2. 
3. 

å½“å‰çŠ¶æ€ï¼š
â–¡ é—®é¢˜å·²è§£å†³
â–¡ é—®é¢˜éƒ¨åˆ†è§£å†³
â–¡ é—®é¢˜æœªè§£å†³

æ ¹æœ¬åŸå› ï¼š

è§£å†³æ–¹æ¡ˆï¼š

é¢„é˜²æªæ–½ï¼š

æ–‡æ¡£æ›´æ–°ï¼š
â–¡ æ›´æ–°çŸ¥è¯†åº“
â–¡ æ›´æ–°æ“ä½œæ‰‹å†Œ
â–¡ å›¢é˜Ÿåˆ†äº«
        "#.to_string()
    }
}

#[derive(Debug)]
pub struct BestPractice {
    category: &'static str,
    practices: Vec<&'static str>,
}
```

## æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†åŒºå—é“¾ç³»ç»Ÿå¸¸è§é—®é¢˜çš„è¯Šæ–­ä¸è§£å†³æ–¹æ¡ˆï¼Œæ¶µç›–ï¼š

1. **è¯Šæ–­æ–¹æ³•è®º**ï¼šç³»ç»ŸåŒ–æµç¨‹ã€æ—¥å¿—åˆ†æã€æ€§èƒ½ç›‘æ§
2. **èŠ‚ç‚¹é—®é¢˜**ï¼šå¯åŠ¨å¤±è´¥ã€åŒæ­¥é—®é¢˜ã€é¢‘ç¹å´©æºƒ
3. **å…±è¯†é—®é¢˜**ï¼šå…±è¯†å¤±è´¥ã€åˆ†å‰ã€ç½‘ç»œåˆ†åŒº
4. **äº¤æ˜“é—®é¢˜**ï¼špendingã€å¤±è´¥ã€gasä¼°ç®—
5. **æ™ºèƒ½åˆçº¦**ï¼šéƒ¨ç½²ã€è°ƒç”¨ã€å®‰å…¨æ¼æ´
6. **ç½‘ç»œé—®é¢˜**ï¼šP2Pè¿æ¥ã€å»¶è¿Ÿã€DDoS
7. **å­˜å‚¨é—®é¢˜**ï¼šæ•°æ®åº“æŸåã€ç©ºé—´ä¸è¶³
8. **æ€§èƒ½é—®é¢˜**ï¼šTPSä½ã€å†…å­˜æ³„æ¼ã€CPUé«˜
9. **å®‰å…¨é—®é¢˜**ï¼šç§é’¥æ³„éœ²ã€51%æ”»å‡»ã€å¥³å·«æ”»å‡»
10. **å·¥å…·ä¸å®è·µ**ï¼šè¯Šæ–­å·¥å…·ã€ç›‘æ§å·¥å…·ã€æœ€ä½³å®è·µ

**å…³é”®è¦ç‚¹**ï¼š

- ç³»ç»ŸåŒ–è¯Šæ–­æµç¨‹
- ä¿ç•™ç°åœºè¯æ®
- å‚è€ƒçŸ¥è¯†åº“
- äº‹åæ€»ç»“æ”¹è¿›

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ17æ—¥  
**ä½œè€…**: RuståŒºå—é“¾æŠ€æœ¯å›¢é˜Ÿ  
**ç›¸å…³æ–‡æ¡£**:

- [11_PERFORMANCE_OPTIMIZATION.md](./11_PERFORMANCE_OPTIMIZATION.md) - æ€§èƒ½ä¼˜åŒ–
- [19_SECURITY_BEST_PRACTICES.md](./19_SECURITY_BEST_PRACTICES.md) - å®‰å…¨æœ€ä½³å®è·µ
- [27_CASE_STUDIES.md](./27_CASE_STUDIES.md) - æ¡ˆä¾‹åˆ†æ
