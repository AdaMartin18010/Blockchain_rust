# Web3æŠ€æœ¯æ ˆ

## ğŸ“‹ ç›®å½•

- [Web3æŠ€æœ¯æ ˆ](#web3æŠ€æœ¯æ ˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. Web3æ¦‚è¿°](#1-web3æ¦‚è¿°)
    - [1.1 Web1 vs Web2 vs Web3](#11-web1-vs-web2-vs-web3)
    - [1.2 Web3æ ¸å¿ƒç‰¹å¾](#12-web3æ ¸å¿ƒç‰¹å¾)
    - [1.3 Web3æŠ€æœ¯æ¶æ„](#13-web3æŠ€æœ¯æ¶æ„)
  - [2. å‰ç«¯æŠ€æœ¯](#2-å‰ç«¯æŠ€æœ¯)
    - [2.1 Web3.js / Ethers.js](#21-web3js--ethersjs)
    - [2.2 Walletè¿æ¥](#22-walletè¿æ¥)
    - [2.3 å»ä¸­å¿ƒåŒ–å‰ç«¯](#23-å»ä¸­å¿ƒåŒ–å‰ç«¯)
  - [3. æ™ºèƒ½åˆçº¦äº¤äº’](#3-æ™ºèƒ½åˆçº¦äº¤äº’)
    - [3.1 åˆçº¦è°ƒç”¨](#31-åˆçº¦è°ƒç”¨)
    - [3.2 äº‹ä»¶ç›‘å¬](#32-äº‹ä»¶ç›‘å¬)
    - [3.3 äº¤æ˜“ç®¡ç†](#33-äº¤æ˜“ç®¡ç†)
  - [4. å»ä¸­å¿ƒåŒ–å­˜å‚¨](#4-å»ä¸­å¿ƒåŒ–å­˜å‚¨)
    - [4.1 IPFS](#41-ipfs)
    - [4.2 Arweave](#42-arweave)
    - [4.3 Filecoin](#43-filecoin)
  - [5. å»ä¸­å¿ƒåŒ–èº«ä»½(DID)](#5-å»ä¸­å¿ƒåŒ–èº«ä»½did)
    - [5.1 DIDè§„èŒƒ](#51-didè§„èŒƒ)
    - [5.2 ENSåŸŸåç³»ç»Ÿ](#52-ensåŸŸåç³»ç»Ÿ)
    - [5.3 å¯éªŒè¯å‡­è¯](#53-å¯éªŒè¯å‡­è¯)
  - [6. Web3é€šä¿¡åè®®](#6-web3é€šä¿¡åè®®)
    - [6.1 libp2p](#61-libp2p)
    - [6.2 Whisper](#62-whisper)
    - [6.3 XMTP](#63-xmtp)
  - [7. é¢„è¨€æœºæœåŠ¡](#7-é¢„è¨€æœºæœåŠ¡)
    - [7.1 Chainlink](#71-chainlink)
    - [7.2 Band Protocol](#72-band-protocol)
    - [7.3 è‡ªå®šä¹‰é¢„è¨€æœº](#73-è‡ªå®šä¹‰é¢„è¨€æœº)
  - [8. Web3å¼€å‘æ¡†æ¶](#8-web3å¼€å‘æ¡†æ¶)
    - [8.1 Hardhat](#81-hardhat)
    - [8.2 Foundry](#82-foundry)
    - [8.3 Truffle](#83-truffle)
  - [9. Web3 UI/UX](#9-web3-uiux)
    - [9.1 Web3è®¾è®¡æ¨¡å¼](#91-web3è®¾è®¡æ¨¡å¼)
    - [9.2 ç”¨æˆ·ä½“éªŒä¼˜åŒ–](#92-ç”¨æˆ·ä½“éªŒä¼˜åŒ–)
    - [9.3 ç»„ä»¶åº“](#93-ç»„ä»¶åº“)
  - [10. Web3å®‰å…¨](#10-web3å®‰å…¨)
    - [10.1 å‰ç«¯å®‰å…¨](#101-å‰ç«¯å®‰å…¨)
    - [10.2 äº¤æ˜“ç­¾åéªŒè¯](#102-äº¤æ˜“ç­¾åéªŒè¯)
    - [10.3 é’“é±¼é˜²æŠ¤](#103-é’“é±¼é˜²æŠ¤)
  - [11. å®æˆ˜é¡¹ç›®ï¼šæ„å»ºWeb3 DApp](#11-å®æˆ˜é¡¹ç›®æ„å»ºweb3-dapp)
    - [11.1 é¡¹ç›®åˆå§‹åŒ–](#111-é¡¹ç›®åˆå§‹åŒ–)
    - [11.2 æ™ºèƒ½åˆçº¦å¼€å‘](#112-æ™ºèƒ½åˆçº¦å¼€å‘)
    - [11.3 å‰ç«¯é›†æˆ](#113-å‰ç«¯é›†æˆ)
  - [12. Web3æœªæ¥å±•æœ›](#12-web3æœªæ¥å±•æœ›)
  - [æ€»ç»“](#æ€»ç»“)
  - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)
  - [å‚è€ƒèµ„æ–™](#å‚è€ƒèµ„æ–™)
  - [å®ç”¨å·¥å…·](#å®ç”¨å·¥å…·)

## 1. Web3æ¦‚è¿°

### 1.1 Web1 vs Web2 vs Web3

```rust
/// Webæ¼”è¿›å†å²
#[derive(Debug, Clone)]
pub struct WebEvolution {
    pub web1: WebEra,
    pub web2: WebEra,
    pub web3: WebEra,
}

#[derive(Debug, Clone)]
pub struct WebEra {
    pub name: String,
    pub period: String,
    pub characteristics: Vec<String>,
    pub key_features: Vec<String>,
    pub examples: Vec<String>,
}

pub fn compare_web_eras() -> WebEvolution {
    WebEvolution {
        web1: WebEra {
            name: "Web 1.0 - åªè¯»ç½‘ç»œ".to_string(),
            period: "1990-2004".to_string(),
            characteristics: vec![
                "é™æ€HTMLé¡µé¢".to_string(),
                "å•å‘ä¿¡æ¯æµ".to_string(),
                "å†…å®¹åˆ›å»ºè€…å°‘".to_string(),
                "ç”¨æˆ·åªèƒ½æµè§ˆ".to_string(),
            ],
            key_features: vec![
                "ä¸ªäººç½‘ç«™".to_string(),
                "é—¨æˆ·ç½‘ç«™".to_string(),
                "ç›®å½•æœåŠ¡".to_string(),
            ],
            examples: vec![
                "Yahoo Directory".to_string(),
                "GeoCities".to_string(),
                "ä¸ªäººä¸»é¡µ".to_string(),
            ],
        },
        web2: WebEra {
            name: "Web 2.0 - è¯»å†™ç½‘ç»œ".to_string(),
            period: "2004-è‡³ä»Š".to_string(),
            characteristics: vec![
                "åŠ¨æ€å†…å®¹".to_string(),
                "ç”¨æˆ·ç”Ÿæˆå†…å®¹(UGC)".to_string(),
                "ç¤¾äº¤åª’ä½“".to_string(),
                "å¹³å°ä¸»å¯¼".to_string(),
                "æ•°æ®ä¸­å¿ƒåŒ–".to_string(),
            ],
            key_features: vec![
                "ç¤¾äº¤ç½‘ç»œ".to_string(),
                "äº‘è®¡ç®—".to_string(),
                "ç§»åŠ¨äº’è”ç½‘".to_string(),
                "SaaS".to_string(),
            ],
            examples: vec![
                "Facebook".to_string(),
                "Twitter".to_string(),
                "YouTube".to_string(),
                "Google".to_string(),
            ],
        },
        web3: WebEra {
            name: "Web 3.0 - è¯»å†™æ‹¥æœ‰ç½‘ç»œ".to_string(),
            period: "2020-æœªæ¥".to_string(),
            characteristics: vec![
                "å»ä¸­å¿ƒåŒ–".to_string(),
                "ç”¨æˆ·æ‹¥æœ‰æ•°æ®".to_string(),
                "æ— éœ€è®¸å¯".to_string(),
                "åŠ å¯†è´§å¸åŸç”Ÿ".to_string(),
                "æ™ºèƒ½åˆçº¦é©±åŠ¨".to_string(),
            ],
            key_features: vec![
                "åŒºå—é“¾".to_string(),
                "å»ä¸­å¿ƒåŒ–èº«ä»½".to_string(),
                "ä»£å¸ç»æµ".to_string(),
                "DAOæ²»ç†".to_string(),
            ],
            examples: vec![
                "Uniswap".to_string(),
                "OpenSea".to_string(),
                "Lens Protocol".to_string(),
                "ENS".to_string(),
            ],
        },
    }
}
```

### 1.2 Web3æ ¸å¿ƒç‰¹å¾

```rust
/// Web3æ ¸å¿ƒç‰¹å¾
#[derive(Debug)]
pub struct Web3CoreFeatures {
    /// å»ä¸­å¿ƒåŒ–
    pub decentralization: DecentralizationFeature,
    
    /// æ— éœ€è®¸å¯
    pub permissionless: PermissionlessFeature,
    
    /// ç”¨æˆ·ä¸»æƒ
    pub user_sovereignty: UserSovereigntyFeature,
    
    /// åŸç”Ÿæ”¯ä»˜
    pub native_payments: NativePaymentFeature,
    
    /// å¯ç»„åˆæ€§
    pub composability: ComposabilityFeature,
}

#[derive(Debug)]
pub struct DecentralizationFeature {
    pub no_single_point_of_failure: bool,
    pub censorship_resistant: bool,
    pub distributed_governance: bool,
}

#[derive(Debug)]
pub struct PermissionlessFeature {
    pub open_participation: bool,
    pub no_gatekeepers: bool,
    pub global_access: bool,
}

#[derive(Debug)]
pub struct UserSovereigntyFeature {
    pub own_data: bool,
    pub own_identity: bool,
    pub own_assets: bool,
    pub portability: bool,
}

#[derive(Debug)]
pub struct NativePaymentFeature {
    pub crypto_native: bool,
    pub programmable_money: bool,
    pub instant_settlement: bool,
    pub global_payments: bool,
}

#[derive(Debug)]
pub struct ComposabilityFeature {
    pub interoperable_protocols: bool,
    pub money_legos: bool,
    pub open_standards: bool,
}
```

### 1.3 Web3æŠ€æœ¯æ¶æ„

```rust
/// Web3æŠ€æœ¯æ ˆ
#[derive(Debug)]
pub struct Web3TechStack {
    /// åŒºå—é“¾å±‚
    pub blockchain_layer: BlockchainLayer,
    
    /// åè®®å±‚
    pub protocol_layer: ProtocolLayer,
    
    /// åº”ç”¨å±‚
    pub application_layer: ApplicationLayer,
    
    /// æ¥å…¥å±‚
    pub access_layer: AccessLayer,
}

#[derive(Debug)]
pub struct BlockchainLayer {
    pub networks: Vec<String>,  // Ethereum, Polygon, etc.
    pub consensus: String,       // PoW, PoS, etc.
    pub smart_contracts: bool,
}

#[derive(Debug)]
pub struct ProtocolLayer {
    pub defi: Vec<String>,      // Uniswap, Aave, etc.
    pub nft: Vec<String>,        // OpenSea, Rarible, etc.
    pub governance: Vec<String>, // Snapshot, Aragon, etc.
    pub storage: Vec<String>,    // IPFS, Arweave, etc.
}

#[derive(Debug)]
pub struct ApplicationLayer {
    pub dapps: Vec<String>,
    pub wallets: Vec<String>,
    pub explorers: Vec<String>,
}

#[derive(Debug)]
pub struct AccessLayer {
    pub web3_providers: Vec<String>,  // Infura, Alchemy, etc.
    pub sdks: Vec<String>,             // Web3.js, Ethers.js, etc.
    pub apis: Vec<String>,
}
```

## 2. å‰ç«¯æŠ€æœ¯

### 2.1 Web3.js / Ethers.js

```rust
/// Web3å‰ç«¯é›†æˆ(Rustè§†è§’ï¼Œå®é™…ä½¿ç”¨JavaScript/TypeScript)
/// ä»¥ä¸‹æ˜¯æ¦‚å¿µæ¨¡å‹

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Web3 Provider
#[derive(Debug)]
pub struct Web3Provider {
    pub rpc_url: String,
    pub chain_id: u64,
    pub network_name: String,
}

impl Web3Provider {
    pub fn new(rpc_url: String, chain_id: u64, network_name: String) -> Self {
        Self {
            rpc_url,
            chain_id,
            network_name,
        }
    }
    
    /// è¿æ¥åˆ°æä¾›å•†
    pub async fn connect(&self) -> Result<Connection, Web3Error> {
        println!("Connecting to {} at {}", self.network_name, self.rpc_url);
        Ok(Connection {
            provider: self.clone(),
            connected: true,
        })
    }
}

#[derive(Debug, Clone)]
pub struct Connection {
    pub provider: Web3Provider,
    pub connected: bool,
}

impl Connection {
    /// è·å–åŒºå—å·
    pub async fn get_block_number(&self) -> Result<u64, Web3Error> {
        // å®é™…å®ç°ä¼šè°ƒç”¨RPC
        Ok(1000000)
    }
    
    /// è·å–ä½™é¢
    pub async fn get_balance(&self, address: &str) -> Result<u128, Web3Error> {
        // å®é™…å®ç°ä¼šè°ƒç”¨eth_getBalance
        Ok(1000000000000000000) // 1 ETH in wei
    }
    
    /// è·å–äº¤æ˜“
    pub async fn get_transaction(&self, tx_hash: &str) -> Result<Transaction, Web3Error> {
        Ok(Transaction {
            hash: tx_hash.to_string(),
            from: "0x0".to_string(),
            to: "0x0".to_string(),
            value: 0,
            data: vec![],
            nonce: 0,
            gas_limit: 21000,
            gas_price: 20000000000,
        })
    }
}

/// äº¤æ˜“ç»“æ„
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub hash: String,
    pub from: String,
    pub to: String,
    pub value: u128,
    pub data: Vec<u8>,
    pub nonce: u64,
    pub gas_limit: u64,
    pub gas_price: u64,
}

#[derive(Debug, thiserror::Error)]
pub enum Web3Error {
    #[error("Connection error: {0}")]
    ConnectionError(String),
    
    #[error("Transaction error: {0}")]
    TransactionError(String),
    
    #[error("Contract error: {0}")]
    ContractError(String),
}
```

### 2.2 Walletè¿æ¥

```rust
/// é’±åŒ…è¿æ¥å™¨
#[derive(Debug)]
pub struct WalletConnector {
    pub connected_wallet: Option<ConnectedWallet>,
    pub supported_wallets: Vec<WalletType>,
}

#[derive(Debug, Clone)]
pub struct ConnectedWallet {
    pub address: String,
    pub wallet_type: WalletType,
    pub chain_id: u64,
}

#[derive(Debug, Clone, PartialEq)]
pub enum WalletType {
    MetaMask,
    WalletConnect,
    Coinbase,
    Ledger,
    Trezor,
    Other(String),
}

impl WalletConnector {
    pub fn new() -> Self {
        Self {
            connected_wallet: None,
            supported_wallets: vec![
                WalletType::MetaMask,
                WalletType::WalletConnect,
                WalletType::Coinbase,
            ],
        }
    }
    
    /// è¿æ¥é’±åŒ…
    pub async fn connect_wallet(
        &mut self,
        wallet_type: WalletType,
    ) -> Result<ConnectedWallet, Web3Error> {
        // å®é™…å®ç°ä¼šæ‰“å¼€é’±åŒ…å¼¹çª—
        println!("Requesting wallet connection: {:?}", wallet_type);
        
        let wallet = ConnectedWallet {
            address: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb".to_string(),
            wallet_type,
            chain_id: 1,
        };
        
        self.connected_wallet = Some(wallet.clone());
        
        Ok(wallet)
    }
    
    /// æ–­å¼€é’±åŒ…
    pub fn disconnect_wallet(&mut self) {
        self.connected_wallet = None;
    }
    
    /// åˆ‡æ¢ç½‘ç»œ
    pub async fn switch_network(&mut self, chain_id: u64) -> Result<(), Web3Error> {
        if let Some(wallet) = &mut self.connected_wallet {
            wallet.chain_id = chain_id;
            Ok(())
        } else {
            Err(Web3Error::ConnectionError("No wallet connected".to_string()))
        }
    }
    
    /// ç­¾åæ¶ˆæ¯
    pub async fn sign_message(&self, message: &str) -> Result<String, Web3Error> {
        if self.connected_wallet.is_none() {
            return Err(Web3Error::ConnectionError("No wallet connected".to_string()));
        }
        
        // å®é™…å®ç°ä¼šè°ƒç”¨é’±åŒ…ç­¾å
        Ok(format!("0x{}", "a".repeat(130)))
    }
}

/// WalletConnectç¤ºä¾‹
pub struct WalletConnectSession {
    pub session_id: String,
    pub bridge_url: String,
    pub connected: bool,
}

impl WalletConnectSession {
    pub async fn create() -> Result<Self, Web3Error> {
        Ok(Self {
            session_id: uuid::Uuid::new_v4().to_string(),
            bridge_url: "https://bridge.walletconnect.org".to_string(),
            connected: false,
        })
    }
    
    pub async fn connect(&mut self) -> Result<String, Web3Error> {
        // ç”ŸæˆäºŒç»´ç 
        let qr_data = format!("wc:{}@1?bridge={}&key={}", 
                             self.session_id, 
                             self.bridge_url,
                             "key");
        
        self.connected = true;
        
        Ok(qr_data)
    }
}
```

### 2.3 å»ä¸­å¿ƒåŒ–å‰ç«¯

```rust
/// IPFSå‰ç«¯æ‰˜ç®¡
#[derive(Debug)]
pub struct IPFSFrontend {
    pub ipfs_gateway: String,
    pub content_hash: Option<String>,
}

impl IPFSFrontend {
    pub fn new(gateway: String) -> Self {
        Self {
            ipfs_gateway: gateway,
            content_hash: None,
        }
    }
    
    /// ä¸Šä¼ å‰ç«¯èµ„æºåˆ°IPFS
    pub async fn upload_app(&mut self, files: Vec<File>) -> Result<String, Web3Error> {
        // å®é™…å®ç°ä¼šä¸Šä¼ åˆ°IPFSèŠ‚ç‚¹
        let content_hash = "QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG".to_string();
        
        self.content_hash = Some(content_hash.clone());
        
        Ok(content_hash)
    }
    
    /// è·å–è®¿é—®URL
    pub fn get_url(&self) -> Option<String> {
        self.content_hash.as_ref().map(|hash| {
            format!("{}/ipfs/{}", self.ipfs_gateway, hash)
        })
    }
    
    /// å›ºå®šå†…å®¹(é˜²æ­¢è¢«åƒåœ¾å›æ”¶)
    pub async fn pin_content(&self, hash: &str) -> Result<(), Web3Error> {
        println!("Pinning content: {}", hash);
        Ok(())
    }
}

#[derive(Debug, Clone)]
pub struct File {
    pub path: String,
    pub content: Vec<u8>,
}

/// ENSåŸŸåç»‘å®š
pub struct ENSBinding {
    pub domain: String,
    pub content_hash: String,
}

impl ENSBinding {
    /// è®¾ç½®ENSå†…å®¹å“ˆå¸Œ
    pub async fn set_content_hash(
        &self,
        wallet: &ConnectedWallet,
    ) -> Result<(), Web3Error> {
        println!("Setting {} -> {}", self.domain, self.content_hash);
        // å®é™…å®ç°ä¼šè°ƒç”¨ENSåˆçº¦
        Ok(())
    }
    
    /// è§£æENS
    pub async fn resolve_ens(domain: &str) -> Result<String, Web3Error> {
        // å®é™…å®ç°ä¼šæŸ¥è¯¢ENSåˆçº¦
        Ok("QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG".to_string())
    }
}
```

## 3. æ™ºèƒ½åˆçº¦äº¤äº’

### 3.1 åˆçº¦è°ƒç”¨

```rust
/// åˆçº¦æ¥å£
#[derive(Debug, Clone)]
pub struct ContractInterface {
    pub address: String,
    pub abi: Vec<ABIFunction>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ABIFunction {
    pub name: String,
    pub inputs: Vec<ABIParameter>,
    pub outputs: Vec<ABIParameter>,
    pub state_mutability: StateMutability,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ABIParameter {
    pub name: String,
    pub param_type: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StateMutability {
    Pure,
    View,
    Nonpayable,
    Payable,
}

/// åˆçº¦å®ä¾‹
pub struct ContractInstance {
    pub interface: ContractInterface,
    pub connection: Connection,
}

impl ContractInstance {
    /// è°ƒç”¨åªè¯»å‡½æ•°
    pub async fn call_view_function(
        &self,
        function_name: &str,
        params: Vec<String>,
    ) -> Result<String, Web3Error> {
        println!("Calling view function: {}({:?})", function_name, params);
        
        // å®é™…å®ç°ä¼šè°ƒç”¨eth_call
        Ok("return_value".to_string())
    }
    
    /// å‘é€äº¤æ˜“(å†™å‡½æ•°)
    pub async fn send_transaction(
        &self,
        function_name: &str,
        params: Vec<String>,
        from: &str,
        value: u128,
    ) -> Result<String, Web3Error> {
        println!("Sending transaction: {}({:?}) from {} value {}", 
                 function_name, params, from, value);
        
        // å®é™…å®ç°ä¼šå‘é€eth_sendTransaction
        Ok("0x".to_string() + &"1".repeat(64))
    }
    
    /// ä¼°ç®—gas
    pub async fn estimate_gas(
        &self,
        function_name: &str,
        params: Vec<String>,
    ) -> Result<u64, Web3Error> {
        // å®é™…å®ç°ä¼šè°ƒç”¨eth_estimateGas
        Ok(50000)
    }
}

/// ERC-20ä»£å¸æ¥å£ç¤ºä¾‹
pub struct ERC20Contract {
    pub contract: ContractInstance,
}

impl ERC20Contract {
    /// æŸ¥è¯¢ä½™é¢
    pub async fn balance_of(&self, account: &str) -> Result<u128, Web3Error> {
        let result = self.contract
            .call_view_function("balanceOf", vec![account.to_string()])
            .await?;
        
        // è§£æè¿”å›å€¼
        Ok(u128::from_str_radix(&result.trim_start_matches("0x"), 16)
           .unwrap_or(0))
    }
    
    /// è½¬è´¦
    pub async fn transfer(
        &self,
        from: &str,
        to: &str,
        amount: u128,
    ) -> Result<String, Web3Error> {
        self.contract.send_transaction(
            "transfer",
            vec![to.to_string(), amount.to_string()],
            from,
            0,
        ).await
    }
    
    /// æˆæƒ
    pub async fn approve(
        &self,
        owner: &str,
        spender: &str,
        amount: u128,
    ) -> Result<String, Web3Error> {
        self.contract.send_transaction(
            "approve",
            vec![spender.to_string(), amount.to_string()],
            owner,
            0,
        ).await
    }
}
```

### 3.2 äº‹ä»¶ç›‘å¬

```rust
use tokio::sync::mpsc;

/// äº‹ä»¶ç›‘å¬å™¨
pub struct EventListener {
    pub contract_address: String,
    pub events: Vec<EventFilter>,
}

#[derive(Debug, Clone)]
pub struct EventFilter {
    pub event_name: String,
    pub topics: Vec<String>,
    pub from_block: u64,
    pub to_block: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventLog {
    pub address: String,
    pub topics: Vec<String>,
    pub data: String,
    pub block_number: u64,
    pub transaction_hash: String,
    pub log_index: u64,
}

impl EventListener {
    /// ç›‘å¬äº‹ä»¶
    pub async fn listen(
        &self,
        connection: &Connection,
    ) -> Result<mpsc::Receiver<EventLog>, Web3Error> {
        let (tx, rx) = mpsc::channel(100);
        
        // å®é™…å®ç°ä¼šä½¿ç”¨WebSocketæˆ–è½®è¯¢
        tokio::spawn(async move {
            // æ¨¡æ‹Ÿäº‹ä»¶æµ
            loop {
                tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
                
                let event = EventLog {
                    address: "0x0".to_string(),
                    topics: vec!["0x0".to_string()],
                    data: "0x0".to_string(),
                    block_number: 1000000,
                    transaction_hash: "0x0".to_string(),
                    log_index: 0,
                };
                
                if tx.send(event).await.is_err() {
                    break;
                }
            }
        });
        
        Ok(rx)
    }
    
    /// è·å–å†å²äº‹ä»¶
    pub async fn get_past_events(
        &self,
        connection: &Connection,
        filter: &EventFilter,
    ) -> Result<Vec<EventLog>, Web3Error> {
        // å®é™…å®ç°ä¼šè°ƒç”¨eth_getLogs
        Ok(vec![])
    }
}

/// Transferäº‹ä»¶ç›‘å¬ç¤ºä¾‹
pub async fn listen_transfer_events(
    token_address: &str,
    connection: &Connection,
) -> Result<(), Web3Error> {
    let listener = EventListener {
        contract_address: token_address.to_string(),
        events: vec![EventFilter {
            event_name: "Transfer".to_string(),
            topics: vec!["0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef".to_string()],
            from_block: 0,
            to_block: None,
        }],
    };
    
    let mut rx = listener.listen(connection).await?;
    
    tokio::spawn(async move {
        while let Some(event) = rx.recv().await {
            println!("Transfer event: {:?}", event);
            // è§£æäº‹ä»¶æ•°æ®
        }
    });
    
    Ok(())
}
```

### 3.3 äº¤æ˜“ç®¡ç†

```rust
/// äº¤æ˜“æ„å»ºå™¨
pub struct TransactionBuilder {
    pub from: String,
    pub to: String,
    pub value: u128,
    pub data: Vec<u8>,
    pub gas_limit: Option<u64>,
    pub gas_price: Option<u64>,
    pub nonce: Option<u64>,
}

impl TransactionBuilder {
    pub fn new(from: String, to: String) -> Self {
        Self {
            from,
            to,
            value: 0,
            data: vec![],
            gas_limit: None,
            gas_price: None,
            nonce: None,
        }
    }
    
    pub fn value(mut self, value: u128) -> Self {
        self.value = value;
        self
    }
    
    pub fn data(mut self, data: Vec<u8>) -> Self {
        self.data = data;
        self
    }
    
    pub fn gas_limit(mut self, gas_limit: u64) -> Self {
        self.gas_limit = Some(gas_limit);
        self
    }
    
    pub async fn send(self, connection: &Connection) -> Result<String, Web3Error> {
        // æ„å»ºå¹¶å‘é€äº¤æ˜“
        let tx_hash = format!("0x{}", "2".repeat(64));
        Ok(tx_hash)
    }
}

/// äº¤æ˜“ç›‘æ§
pub struct TransactionMonitor {
    pub tx_hash: String,
}

impl TransactionMonitor {
    /// ç­‰å¾…äº¤æ˜“ç¡®è®¤
    pub async fn wait_for_confirmation(
        &self,
        connection: &Connection,
        confirmations: u64,
    ) -> Result<TransactionReceipt, Web3Error> {
        // è½®è¯¢äº¤æ˜“çŠ¶æ€
        loop {
            tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
            
            // æ£€æŸ¥äº¤æ˜“æ˜¯å¦è¢«ç¡®è®¤
            // å®é™…å®ç°ä¼šè°ƒç”¨eth_getTransactionReceipt
            
            return Ok(TransactionReceipt {
                transaction_hash: self.tx_hash.clone(),
                block_number: 1000000,
                status: true,
                gas_used: 21000,
            });
        }
    }
}

#[derive(Debug, Clone)]
pub struct TransactionReceipt {
    pub transaction_hash: String,
    pub block_number: u64,
    pub status: bool,
    pub gas_used: u64,
}

/// æ‰¹é‡äº¤æ˜“
pub struct BatchTransaction {
    pub transactions: Vec<TransactionBuilder>,
}

impl BatchTransaction {
    pub async fn send_all(
        self,
        connection: &Connection,
    ) -> Result<Vec<String>, Web3Error> {
        let mut tx_hashes = Vec::new();
        
        for tx in self.transactions {
            let hash = tx.send(connection).await?;
            tx_hashes.push(hash);
        }
        
        Ok(tx_hashes)
    }
}
```

## 4. å»ä¸­å¿ƒåŒ–å­˜å‚¨

### 4.1 IPFS

```rust
use reqwest;

/// IPFSå®¢æˆ·ç«¯
pub struct IPFSClient {
    pub api_url: String,
    pub gateway_url: String,
}

impl IPFSClient {
    pub fn new(api_url: String, gateway_url: String) -> Self {
        Self {
            api_url,
            gateway_url,
        }
    }
    
    /// æ·»åŠ æ–‡ä»¶
    pub async fn add_file(&self, content: Vec<u8>) -> Result<String, Web3Error> {
        // å®é™…å®ç°ä¼šè°ƒç”¨IPFS API
        let cid = "QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG".to_string();
        
        println!("Added file to IPFS: {}", cid);
        
        Ok(cid)
    }
    
    /// è·å–æ–‡ä»¶
    pub async fn get_file(&self, cid: &str) -> Result<Vec<u8>, Web3Error> {
        let url = format!("{}/ipfs/{}", self.gateway_url, cid);
        
        // å®é™…å®ç°ä¼šHTTP GET
        Ok(vec![])
    }
    
    /// æ·»åŠ JSONæ•°æ®
    pub async fn add_json<T: Serialize>(&self, data: &T) -> Result<String, Web3Error> {
        let json_bytes = serde_json::to_vec(data)
            .map_err(|e| Web3Error::ConnectionError(e.to_string()))?;
        
        self.add_file(json_bytes).await
    }
    
    /// è·å–JSONæ•°æ®
    pub async fn get_json<T: for<'de> Deserialize<'de>>(
        &self,
        cid: &str,
    ) -> Result<T, Web3Error> {
        let bytes = self.get_file(cid).await?;
        
        serde_json::from_slice(&bytes)
            .map_err(|e| Web3Error::ConnectionError(e.to_string()))
    }
    
    /// å›ºå®šæ–‡ä»¶
    pub async fn pin(&self, cid: &str) -> Result<(), Web3Error> {
        println!("Pinning CID: {}", cid);
        Ok(())
    }
    
    /// å–æ¶ˆå›ºå®š
    pub async fn unpin(&self, cid: &str) -> Result<(), Web3Error> {
        println!("Unpinning CID: {}", cid);
        Ok(())
    }
}

/// NFTå…ƒæ•°æ®ç¤ºä¾‹
#[derive(Debug, Serialize, Deserialize)]
pub struct NFTMetadata {
    pub name: String,
    pub description: String,
    pub image: String,
    pub attributes: Vec<NFTAttribute>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NFTAttribute {
    pub trait_type: String,
    pub value: String,
}

/// ä¸Šä¼ NFTå…ƒæ•°æ®åˆ°IPFS
pub async fn upload_nft_metadata(
    ipfs: &IPFSClient,
    metadata: NFTMetadata,
) -> Result<String, Web3Error> {
    // å…ˆä¸Šä¼ å›¾ç‰‡
    // let image_cid = ipfs.add_file(image_data).await?;
    
    // æ›´æ–°å…ƒæ•°æ®ä¸­çš„å›¾ç‰‡URL
    // metadata.image = format!("ipfs://{}", image_cid);
    
    // ä¸Šä¼ å…ƒæ•°æ®
    let metadata_cid = ipfs.add_json(&metadata).await?;
    
    Ok(metadata_cid)
}
```

### 4.2 Arweave

```rust
/// Arweaveå®¢æˆ·ç«¯
pub struct ArweaveClient {
    pub gateway_url: String,
}

impl ArweaveClient {
    pub fn new(gateway_url: String) -> Self {
        Self { gateway_url }
    }
    
    /// ä¸Šä¼ æ•°æ®(æ°¸ä¹…å­˜å‚¨)
    pub async fn upload(
        &self,
        data: Vec<u8>,
        tags: Vec<(String, String)>,
    ) -> Result<String, Web3Error> {
        // å®é™…å®ç°ä¼šåˆ›å»ºArweaveäº¤æ˜“
        let tx_id = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFG".to_string();
        
        println!("Uploaded to Arweave: {}", tx_id);
        
        Ok(tx_id)
    }
    
    /// è·å–æ•°æ®
    pub async fn get(&self, tx_id: &str) -> Result<Vec<u8>, Web3Error> {
        let url = format!("{}/{}", self.gateway_url, tx_id);
        
        // å®é™…å®ç°ä¼šHTTP GET
        Ok(vec![])
    }
    
    /// æŸ¥è¯¢äº¤æ˜“
    pub async fn query_transactions(
        &self,
        tags: Vec<(String, String)>,
    ) -> Result<Vec<String>, Web3Error> {
        // å®é™…å®ç°ä¼šä½¿ç”¨GraphQLæŸ¥è¯¢
        Ok(vec![])
    }
}

/// Arweaveæ ‡ç­¾
pub struct ArweaveTags {
    pub tags: Vec<(String, String)>,
}

impl ArweaveTags {
    pub fn new() -> Self {
        Self { tags: vec![] }
    }
    
    pub fn add_tag(mut self, name: String, value: String) -> Self {
        self.tags.push((name, value));
        self
    }
    
    pub fn content_type(self, content_type: &str) -> Self {
        self.add_tag("Content-Type".to_string(), content_type.to_string())
    }
    
    pub fn app_name(self, app_name: &str) -> Self {
        self.add_tag("App-Name".to_string(), app_name.to_string())
    }
}
```

### 4.3 Filecoin

```rust
/// Filecoinå­˜å‚¨äº¤æ˜“
pub struct FilecoinClient {
    pub lotus_url: String,
}

impl FilecoinClient {
    /// åˆ›å»ºå­˜å‚¨äº¤æ˜“
    pub async fn create_storage_deal(
        &self,
        data_cid: &str,
        miner: &str,
        duration: u64,
        price: u64,
    ) -> Result<String, Web3Error> {
        println!("Creating storage deal with miner {} for {} epochs",
                 miner, duration);
        
        // å®é™…å®ç°ä¼šè°ƒç”¨Lotus API
        Ok("deal_id".to_string())
    }
    
    /// æŸ¥è¯¢äº¤æ˜“çŠ¶æ€
    pub async fn check_deal_status(&self, deal_id: &str) -> Result<DealStatus, Web3Error> {
        Ok(DealStatus::Active)
    }
}

#[derive(Debug, Clone)]
pub enum DealStatus {
    Pending,
    Active,
    Expired,
    Failed,
}
```

## 5. å»ä¸­å¿ƒåŒ–èº«ä»½(DID)

### 5.1 DIDè§„èŒƒ

```rust
/// DIDæ–‡æ¡£
#[derive(Debug, Serialize, Deserialize)]
pub struct DIDDocument {
    #[serde(rename = "@context")]
    pub context: Vec<String>,
    
    pub id: String,  // did:method:identifier
    
    pub verification_method: Vec<VerificationMethod>,
    
    pub authentication: Vec<String>,
    
    pub assertion_method: Option<Vec<String>>,
    
    pub service: Option<Vec<Service>>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct VerificationMethod {
    pub id: String,
    
    #[serde(rename = "type")]
    pub method_type: String,
    
    pub controller: String,
    
    pub public_key_base58: Option<String>,
    
    pub public_key_jwk: Option<serde_json::Value>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Service {
    pub id: String,
    
    #[serde(rename = "type")]
    pub service_type: String,
    
    pub service_endpoint: String,
}

/// DIDåˆ›å»º
pub fn create_did(method: &str, identifier: &str) -> String {
    format!("did:{}:{}", method, identifier)
}

/// ç¤ºä¾‹ï¼šä»¥å¤ªåŠåœ°å€çš„DID
pub fn eth_address_to_did(address: &str) -> String {
    create_did("ethr", address)
}
```

### 5.2 ENSåŸŸåç³»ç»Ÿ

```rust
/// ENSè§£æå™¨
pub struct ENSResolver {
    pub contract: ContractInstance,
}

impl ENSResolver {
    /// è§£æåŸŸååˆ°åœ°å€
    pub async fn resolve(&self, domain: &str) -> Result<String, Web3Error> {
        // è®¡ç®—åŸŸåå“ˆå¸Œ
        let node = Self::namehash(domain);
        
        // è°ƒç”¨resolveråˆçº¦
        self.contract
            .call_view_function("addr", vec![node])
            .await
    }
    
    /// åå‘è§£æ(åœ°å€åˆ°åŸŸå)
    pub async fn reverse_resolve(&self, address: &str) -> Result<String, Web3Error> {
        let reverse_domain = format!("{}.addr.reverse", 
                                    address.trim_start_matches("0x"));
        
        self.contract
            .call_view_function("name", vec![Self::namehash(&reverse_domain)])
            .await
    }
    
    /// è®¾ç½®åŸŸåè§£æ
    pub async fn set_address(
        &self,
        domain: &str,
        address: &str,
        from: &str,
    ) -> Result<String, Web3Error> {
        let node = Self::namehash(domain);
        
        self.contract
            .send_transaction(
                "setAddr",
                vec![node, address.to_string()],
                from,
                0,
            )
            .await
    }
    
    /// Namehashç®—æ³•
    fn namehash(domain: &str) -> String {
        use sha3::{Digest, Keccak256};
        
        let mut node = [0u8; 32];
        
        if !domain.is_empty() {
            let labels: Vec<&str> = domain.split('.').rev().collect();
            
            for label in labels {
                let mut hasher = Keccak256::new();
                hasher.update(node);
                hasher.update(Keccak256::digest(label.as_bytes()));
                node = hasher.finalize().into();
            }
        }
        
        format!("0x{}", hex::encode(node))
    }
    
    /// è·å–å†…å®¹å“ˆå¸Œ
    pub async fn get_content_hash(&self, domain: &str) -> Result<String, Web3Error> {
        let node = Self::namehash(domain);
        
        self.contract
            .call_view_function("contenthash", vec![node])
            .await
    }
}
```

### 5.3 å¯éªŒè¯å‡­è¯

```rust
/// å¯éªŒè¯å‡­è¯(Verifiable Credential)
#[derive(Debug, Serialize, Deserialize)]
pub struct VerifiableCredential {
    #[serde(rename = "@context")]
    pub context: Vec<String>,
    
    pub id: String,
    
    #[serde(rename = "type")]
    pub credential_type: Vec<String>,
    
    pub issuer: String,
    
    pub issuance_date: String,
    
    pub expiration_date: Option<String>,
    
    pub credential_subject: serde_json::Value,
    
    pub proof: Proof,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Proof {
    #[serde(rename = "type")]
    pub proof_type: String,
    
    pub created: String,
    
    pub verification_method: String,
    
    pub proof_purpose: String,
    
    pub jws: String,
}

/// VCå‘è¡Œè€…
pub struct VCIssuer {
    pub did: String,
    pub private_key: Vec<u8>,
}

impl VCIssuer {
    /// å‘è¡Œå‡­è¯
    pub fn issue_credential(
        &self,
        subject: serde_json::Value,
        credential_type: Vec<String>,
    ) -> Result<VerifiableCredential, Web3Error> {
        let now = chrono::Utc::now().to_rfc3339();
        
        let credential = VerifiableCredential {
            context: vec![
                "https://www.w3.org/2018/credentials/v1".to_string(),
            ],
            id: format!("urn:uuid:{}", uuid::Uuid::new_v4()),
            credential_type,
            issuer: self.did.clone(),
            issuance_date: now.clone(),
            expiration_date: None,
            credential_subject: subject,
            proof: Proof {
                proof_type: "EcdsaSecp256k1Signature2019".to_string(),
                created: now,
                verification_method: format!("{}#keys-1", self.did),
                proof_purpose: "assertionMethod".to_string(),
                jws: "...".to_string(), // å®é™…å®ç°ä¼šç­¾å
            },
        };
        
        Ok(credential)
    }
}

/// VCéªŒè¯è€…
pub struct VCVerifier;

impl VCVerifier {
    /// éªŒè¯å‡­è¯
    pub fn verify_credential(
        &self,
        credential: &VerifiableCredential,
    ) -> Result<bool, Web3Error> {
        // 1. éªŒè¯ç­¾å
        // 2. éªŒè¯å‘è¡Œè€…
        // 3. éªŒè¯è¿‡æœŸæ—¶é—´
        // 4. éªŒè¯æ’¤é”€çŠ¶æ€
        
        Ok(true)
    }
}
```

## 6. Web3é€šä¿¡åè®®

### 6.1 libp2p

```rust
/// libp2pèŠ‚ç‚¹(ç®€åŒ–æ¦‚å¿µæ¨¡å‹)
pub struct Libp2pNode {
    pub peer_id: String,
    pub listen_addresses: Vec<String>,
    pub peers: Vec<PeerInfo>,
}

#[derive(Debug, Clone)]
pub struct PeerInfo {
    pub peer_id: String,
    pub addresses: Vec<String>,
    pub protocols: Vec<String>,
}

impl Libp2pNode {
    /// è¿æ¥åˆ°peer
    pub async fn connect(&mut self, address: &str) -> Result<(), Web3Error> {
        println!("Connecting to peer: {}", address);
        Ok(())
    }
    
    /// å‘å¸ƒæ¶ˆæ¯(PubSub)
    pub async fn publish(&self, topic: &str, message: &[u8]) -> Result<(), Web3Error> {
        println!("Publishing to topic {}: {} bytes", topic, message.len());
        Ok(())
    }
    
    /// è®¢é˜…ä¸»é¢˜
    pub async fn subscribe(&mut self, topic: &str) -> Result<(), Web3Error> {
        println!("Subscribed to topic: {}", topic);
        Ok(())
    }
}
```

### 6.2 Whisper

```rust
/// Whisperæ¶ˆæ¯
pub struct WhisperMessage {
    pub payload: Vec<u8>,
    pub topic: [u8; 4],
    pub ttl: u64,
    pub pow: f64,
}

pub struct WhisperClient {
    pub connection: Connection,
}

impl WhisperClient {
    /// å‘é€æ¶ˆæ¯
    pub async fn send_message(&self, message: WhisperMessage) -> Result<String, Web3Error> {
        println!("Sending Whisper message");
        Ok("message_hash".to_string())
    }
    
    /// åˆ›å»ºè¿‡æ»¤å™¨
    pub async fn new_filter(&self, topics: Vec<[u8; 4]>) -> Result<String, Web3Error> {
        Ok("filter_id".to_string())
    }
    
    /// è·å–æ¶ˆæ¯
    pub async fn get_messages(&self, filter_id: &str) -> Result<Vec<WhisperMessage>, Web3Error> {
        Ok(vec![])
    }
}
```

### 6.3 XMTP

```rust
/// XMTPå®¢æˆ·ç«¯(å»ä¸­å¿ƒåŒ–æ¶ˆæ¯åè®®)
pub struct XMTPClient {
    pub wallet: ConnectedWallet,
}

impl XMTPClient {
    /// å‘é€æ¶ˆæ¯
    pub async fn send_message(
        &self,
        to: &str,
        content: &str,
    ) -> Result<(), Web3Error> {
        println!("Sending XMTP message to {}: {}", to, content);
        Ok(())
    }
    
    /// æ¥æ”¶æ¶ˆæ¯
    pub async fn receive_messages(&self) -> Result<Vec<Message>, Web3Error> {
        Ok(vec![])
    }
}

#[derive(Debug, Clone)]
pub struct Message {
    pub from: String,
    pub to: String,
    pub content: String,
    pub timestamp: u64,
}
```

## 7. é¢„è¨€æœºæœåŠ¡

### 7.1 Chainlink

```rust
/// Chainlinkä»·æ ¼èšåˆå™¨
pub struct ChainlinkPriceFeed {
    pub aggregator_contract: ContractInstance,
}

impl ChainlinkPriceFeed {
    /// è·å–æœ€æ–°ä»·æ ¼
    pub async fn get_latest_price(&self) -> Result<i128, Web3Error> {
        let result = self.aggregator_contract
            .call_view_function("latestRoundData", vec![])
            .await?;
        
        // è§£æè¿”å›å€¼(roundId, answer, startedAt, updatedAt, answeredInRound)
        Ok(0)
    }
    
    /// è·å–å†å²ä»·æ ¼
    pub async fn get_historical_price(&self, round_id: u64) -> Result<i128, Web3Error> {
        self.aggregator_contract
            .call_view_function("getRoundData", vec![round_id.to_string()])
            .await?;
        
        Ok(0)
    }
}
```

### 7.2 Band Protocol

```rust
/// Band Protocolå®¢æˆ·ç«¯
pub struct BandProtocolClient {
    pub contract: ContractInstance,
}

impl BandProtocolClient {
    /// æŸ¥è¯¢æ•°æ®
    pub async fn get_reference_data(
        &self,
        base: &str,
        quote: &str,
    ) -> Result<(u64, u64), Web3Error> {
        // è¿”å›(rate, lastUpdatedBase, lastUpdatedQuote)
        Ok((100, 0))
    }
}
```

### 7.3 è‡ªå®šä¹‰é¢„è¨€æœº

```rust
/// è‡ªå®šä¹‰é¢„è¨€æœº
pub struct CustomOracle {
    pub contract: ContractInstance,
    pub api_url: String,
}

impl CustomOracle {
    /// è¯·æ±‚æ•°æ®
    pub async fn request_data(
        &self,
        job_id: &str,
        params: serde_json::Value,
    ) -> Result<String, Web3Error> {
        // å‘é€è¯·æ±‚åˆ°é¢„è¨€æœºèŠ‚ç‚¹
        let request_id = self.contract
            .send_transaction(
                "requestData",
                vec![job_id.to_string(), params.to_string()],
                "0x0",
                0,
            )
            .await?;
        
        Ok(request_id)
    }
    
    /// æŸ¥è¯¢ç»“æœ
    pub async fn get_result(&self, request_id: &str) -> Result<Vec<u8>, Web3Error> {
        self.contract
            .call_view_function("getResult", vec![request_id.to_string()])
            .await?;
        
        Ok(vec![])
    }
}
```

## 8. Web3å¼€å‘æ¡†æ¶

### 8.1 Hardhat

```rust
/// Hardhaté¡¹ç›®é…ç½®(æ¦‚å¿µæ¨¡å‹)
#[derive(Debug, Serialize, Deserialize)]
pub struct HardhatConfig {
    pub solidity: SolidityConfig,
    pub networks: HashMap<String, NetworkConfig>,
    pub paths: PathsConfig,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SolidityConfig {
    pub version: String,
    pub settings: CompilerSettings,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CompilerSettings {
    pub optimizer: OptimizerConfig,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OptimizerConfig {
    pub enabled: bool,
    pub runs: u32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkConfig {
    pub url: String,
    pub chain_id: u64,
    pub accounts: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PathsConfig {
    pub sources: String,
    pub tests: String,
    pub artifacts: String,
}
```

### 8.2 Foundry

```rust
/// Foundryé…ç½®
#[derive(Debug, Serialize, Deserialize)]
pub struct FoundryConfig {
    pub profile: ProfileConfig,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ProfileConfig {
    pub src: String,
    pub out: String,
    pub libs: Vec<String>,
    pub solc_version: String,
    pub optimizer: bool,
    pub optimizer_runs: u32,
}
```

### 8.3 Truffle

```rust
/// Truffleé…ç½®
#[derive(Debug, Serialize, Deserialize)]
pub struct TruffleConfig {
    pub networks: HashMap<String, TruffleNetworkConfig>,
    pub compilers: CompilersConfig,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TruffleNetworkConfig {
    pub host: String,
    pub port: u16,
    pub network_id: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CompilersConfig {
    pub solc: SolcConfig,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SolcConfig {
    pub version: String,
}
```

## 9. Web3 UI/UX

### 9.1 Web3è®¾è®¡æ¨¡å¼

```rust
/// Web3 UIç»„ä»¶æ¨¡å¼
pub enum Web3UIPattern {
    /// é’±åŒ…è¿æ¥æŒ‰é’®
    WalletConnectButton {
        label: String,
        supported_wallets: Vec<WalletType>,
    },
    
    /// ç½‘ç»œåˆ‡æ¢å™¨
    NetworkSwitcher {
        networks: Vec<NetworkInfo>,
        current_network: u64,
    },
    
    /// äº¤æ˜“ç¡®è®¤å¼¹çª—
    TransactionModal {
        transaction: Transaction,
        status: TransactionStatus,
    },
    
    /// ä½™é¢æ˜¾ç¤º
    BalanceDisplay {
        token_symbol: String,
        balance: u128,
        usd_value: Option<f64>,
    },
    
    /// Gasè´¹ç”¨ä¼°ç®—
    GasEstimator {
        estimated_gas: u64,
        gas_price: u64,
        total_cost: u128,
    },
}

#[derive(Debug, Clone)]
pub struct NetworkInfo {
    pub name: String,
    pub chain_id: u64,
    pub rpc_url: String,
    pub explorer_url: String,
    pub currency_symbol: String,
}

#[derive(Debug, Clone)]
pub enum TransactionStatus {
    Pending,
    Confirmed(u64),  // confirmations
    Failed(String),
}
```

### 9.2 ç”¨æˆ·ä½“éªŒä¼˜åŒ–

```rust
/// äº¤æ˜“çŠ¶æ€ç®¡ç†
pub struct TransactionStateManager {
    pub pending_txs: Vec<PendingTransaction>,
}

#[derive(Debug, Clone)]
pub struct PendingTransaction {
    pub hash: String,
    pub description: String,
    pub submitted_at: u64,
    pub status: TransactionStatus,
}

impl TransactionStateManager {
    /// æ·»åŠ å¾…å¤„ç†äº¤æ˜“
    pub fn add_transaction(&mut self, tx: PendingTransaction) {
        self.pending_txs.push(tx);
    }
    
    /// æ›´æ–°äº¤æ˜“çŠ¶æ€
    pub fn update_status(&mut self, tx_hash: &str, status: TransactionStatus) {
        if let Some(tx) = self.pending_txs.iter_mut().find(|t| t.hash == tx_hash) {
            tx.status = status;
        }
    }
    
    /// ç§»é™¤å·²å®Œæˆäº¤æ˜“
    pub fn remove_completed(&mut self) {
        self.pending_txs.retain(|tx| {
            !matches!(tx.status, TransactionStatus::Confirmed(_))
        });
    }
}

/// é”™è¯¯æç¤º
pub struct ErrorHandler;

impl ErrorHandler {
    pub fn user_friendly_error(error: &Web3Error) -> String {
        match error {
            Web3Error::ConnectionError(msg) => {
                format!("è¿æ¥é”™è¯¯: {}ã€‚è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–åˆ‡æ¢RPCèŠ‚ç‚¹ã€‚", msg)
            }
            Web3Error::TransactionError(msg) => {
                if msg.contains("insufficient funds") {
                    "ä½™é¢ä¸è¶³ï¼Œè¯·ç¡®ä¿è´¦æˆ·æœ‰è¶³å¤Ÿçš„èµ„é‡‘ã€‚".to_string()
                } else if msg.contains("gas") {
                    "Gasè´¹ç”¨ä¸è¶³æˆ–è®¾ç½®è¿‡ä½ï¼Œè¯·å¢åŠ Gasé™åˆ¶ã€‚".to_string()
                } else {
                    format!("äº¤æ˜“å¤±è´¥: {}", msg)
                }
            }
            Web3Error::ContractError(msg) => {
                format!("æ™ºèƒ½åˆçº¦é”™è¯¯: {}ã€‚è¯·æ£€æŸ¥åˆçº¦è°ƒç”¨å‚æ•°ã€‚", msg)
            }
        }
    }
}
```

### 9.3 ç»„ä»¶åº“

```rust
/// Web3 Reactç»„ä»¶(æ¦‚å¿µæ¨¡å‹)
pub enum Web3Component {
    ConnectButton {
        on_connect: fn(ConnectedWallet),
    },
    
    NetworkSelector {
        networks: Vec<NetworkInfo>,
        on_switch: fn(u64),
    },
    
    TokenBalance {
        token_address: String,
        user_address: String,
    },
    
    TransactionList {
        transactions: Vec<PendingTransaction>,
    },
    
    NFTGallery {
        nfts: Vec<NFTItem>,
        on_select: fn(NFTItem),
    },
}

#[derive(Debug, Clone)]
pub struct NFTItem {
    pub token_id: String,
    pub name: String,
    pub image_url: String,
    pub metadata: NFTMetadata,
}
```

## 10. Web3å®‰å…¨

### 10.1 å‰ç«¯å®‰å…¨

```rust
/// è¾“å…¥éªŒè¯
pub struct InputValidator;

impl InputValidator {
    /// éªŒè¯ä»¥å¤ªåŠåœ°å€
    pub fn validate_eth_address(address: &str) -> bool {
        if !address.starts_with("0x") {
            return false;
        }
        
        if address.len() != 42 {
            return false;
        }
        
        // éªŒè¯æ ¡éªŒå’Œ(å®é™…å®ç°éœ€è¦å®Œæ•´çš„æ ¡éªŒå’ŒéªŒè¯)
        true
    }
    
    /// éªŒè¯é‡‘é¢
    pub fn validate_amount(amount: &str, decimals: u8) -> Result<u128, String> {
        let parts: Vec<&str> = amount.split('.').collect();
        
        if parts.len() > 2 {
            return Err("Invalid amount format".to_string());
        }
        
        let integer_part: u128 = parts[0].parse()
            .map_err(|_| "Invalid integer part".to_string())?;
        
        let fractional_part: u128 = if parts.len() == 2 {
            if parts[1].len() > decimals as usize {
                return Err("Too many decimal places".to_string());
            }
            
            let padded = format!("{:0<width$}", parts[1], width = decimals as usize);
            padded.parse().map_err(|_| "Invalid fractional part".to_string())?
        } else {
            0
        };
        
        let total = integer_part * 10u128.pow(decimals as u32) + fractional_part;
        
        Ok(total)
    }
}
```

### 10.2 äº¤æ˜“ç­¾åéªŒè¯

```rust
/// ç­¾åéªŒè¯
pub struct SignatureVerifier;

impl SignatureVerifier {
    /// éªŒè¯æ¶ˆæ¯ç­¾å
    pub fn verify_signature(
        message: &str,
        signature: &str,
        expected_signer: &str,
    ) -> Result<bool, Web3Error> {
        // å®é™…å®ç°ä¼šä½¿ç”¨ethersåº“è¿›è¡Œç­¾åæ¢å¤
        // 1. å¯¹æ¶ˆæ¯è¿›è¡Œä»¥å¤ªåŠå‰ç¼€å¤„ç†
        // 2. ä»ç­¾åæ¢å¤å…¬é’¥
        // 3. ä»å…¬é’¥æ´¾ç”Ÿåœ°å€
        // 4. æ¯”è¾ƒåœ°å€
        
        Ok(true)
    }
    
    /// EIP-712ç»“æ„åŒ–æ•°æ®ç­¾å
    pub fn verify_typed_data(
        domain: serde_json::Value,
        types: serde_json::Value,
        value: serde_json::Value,
        signature: &str,
    ) -> Result<bool, Web3Error> {
        // å®é™…å®ç°ä¼šæ„å»ºEIP-712å“ˆå¸Œå¹¶éªŒè¯
        Ok(true)
    }
}
```

### 10.3 é’“é±¼é˜²æŠ¤

```rust
/// é’“é±¼æ£€æµ‹
pub struct PhishingDetector {
    pub known_scams: Vec<String>,
    pub verified_domains: Vec<String>,
}

impl PhishingDetector {
    /// æ£€æŸ¥URLæ˜¯å¦å®‰å…¨
    pub fn check_url(&self, url: &str) -> SecurityLevel {
        if self.verified_domains.iter().any(|d| url.contains(d)) {
            return SecurityLevel::Safe;
        }
        
        if self.known_scams.iter().any(|s| url.contains(s)) {
            return SecurityLevel::Dangerous;
        }
        
        SecurityLevel::Unknown
    }
    
    /// æ£€æŸ¥åˆçº¦åœ°å€
    pub fn check_contract(&self, address: &str) -> SecurityLevel {
        // å®é™…å®ç°ä¼šæŸ¥è¯¢åˆçº¦éªŒè¯æ•°æ®åº“
        SecurityLevel::Unknown
    }
    
    /// åˆ†æäº¤æ˜“é£é™©
    pub fn analyze_transaction(&self, tx: &Transaction) -> Vec<SecurityWarning> {
        let mut warnings = Vec::new();
        
        // æ£€æŸ¥å¤§é¢è½¬è´¦
        if tx.value > 1000000000000000000 {  // > 1 ETH
            warnings.push(SecurityWarning::LargeTransfer);
        }
        
        // æ£€æŸ¥æœªçŸ¥åˆçº¦
        if !tx.data.is_empty() {
            warnings.push(SecurityWarning::SmartContractInteraction);
        }
        
        warnings
    }
}

#[derive(Debug, Clone, Copy)]
pub enum SecurityLevel {
    Safe,
    Unknown,
    Suspicious,
    Dangerous,
}

#[derive(Debug, Clone)]
pub enum SecurityWarning {
    LargeTransfer,
    SmartContractInteraction,
    UnverifiedContract,
    HighGasPrice,
    TokenApproval,
}
```

## 11. å®æˆ˜é¡¹ç›®ï¼šæ„å»ºWeb3 DApp

### 11.1 é¡¹ç›®åˆå§‹åŒ–

```rust
/// DAppé¡¹ç›®ç»“æ„
pub struct DAppProject {
    pub name: String,
    pub frontend: FrontendConfig,
    pub contracts: ContractsConfig,
    pub deployment: DeploymentConfig,
}

pub struct FrontendConfig {
    pub framework: String,  // React, Vue, etc.
    pub web3_library: String,  // ethers.js, web3.js
    pub ui_library: Option<String>,  // RainbowKit, Web3Modal
}

pub struct ContractsConfig {
    pub language: String,  // Solidity, Vyper
    pub compiler_version: String,
    pub test_framework: String,  // Hardhat, Foundry
}

pub struct DeploymentConfig {
    pub networks: Vec<String>,
    pub ipfs_gateway: Option<String>,
    pub ens_domain: Option<String>,
}
```

### 11.2 æ™ºèƒ½åˆçº¦å¼€å‘

```solidity
// SimpleToken.sol - ç¤ºä¾‹ERC-20ä»£å¸åˆçº¦
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleToken {
    string public name = "Simple Token";
    string public symbol = "SIM";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }
    
    function transfer(address to, uint256 value) public returns (bool) {
        require(balanceOf[msg.sender] >= value, "Insufficient balance");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }
    
    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
    
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(balanceOf[from] >= value, "Insufficient balance");
        require(allowance[from][msg.sender] >= value, "Insufficient allowance");
        
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        
        emit Transfer(from, to, value);
        return true;
    }
}
```

### 11.3 å‰ç«¯é›†æˆ

```typescript
// å‰ç«¯é›†æˆç¤ºä¾‹(TypeScript)
/*
import { ethers } from 'ethers';
import SimpleTokenABI from './SimpleToken.json';

class TokenDApp {
    provider: ethers.providers.Web3Provider;
    signer: ethers.Signer;
    contract: ethers.Contract;
    
    async connect() {
        // è¿æ¥MetaMask
        this.provider = new ethers.providers.Web3Provider(window.ethereum);
        await this.provider.send("eth_requestAccounts", []);
        this.signer = this.provider.getSigner();
        
        // è¿æ¥åˆçº¦
        const contractAddress = "0x...";
        this.contract = new ethers.Contract(
            contractAddress,
            SimpleTokenABI,
            this.signer
        );
    }
    
    async getBalance(address: string): Promise<string> {
        const balance = await this.contract.balanceOf(address);
        return ethers.utils.formatEther(balance);
    }
    
    async transfer(to: string, amount: string): Promise<ethers.ContractTransaction> {
        const tx = await this.contract.transfer(
            to,
            ethers.utils.parseEther(amount)
        );
        await tx.wait();
        return tx;
    }
}
*/
```

## 12. Web3æœªæ¥å±•æœ›

```rust
/// Web3æœªæ¥è¶‹åŠ¿
#[derive(Debug)]
pub enum Web3FutureTrend {
    /// Account Abstraction (è´¦æˆ·æŠ½è±¡)
    AccountAbstraction {
        social_recovery: bool,
        gas_sponsorship: bool,
        batch_transactions: bool,
    },
    
    /// Layer 2æ‰©å®¹
    Layer2Scaling {
        optimistic_rollups: bool,
        zk_rollups: bool,
        validium: bool,
    },
    
    /// é“¾æŠ½è±¡
    ChainAbstraction {
        cross_chain_messaging: bool,
        unified_liquidity: bool,
        chain_agnostic_apps: bool,
    },
    
    /// AI + Web3
    AIWeb3 {
        ai_agents: bool,
        personalized_defi: bool,
        automated_governance: bool,
    },
    
    /// éšç§å¢å¼º
    PrivacyEnhancement {
        zero_knowledge_proofs: bool,
        fully_homomorphic_encryption: bool,
        confidential_smart_contracts: bool,
    },
    
    /// ç‰©è”ç½‘é›†æˆ
    IoTIntegration {
        device_identity: bool,
        micro_payments: bool,
        supply_chain_tracking: bool,
    },
}

/// Web3å‘å±•æ–¹å‘
pub struct Web3Roadmap {
    pub scalability: ScalabilityGoals,
    pub usability: UsabilityGoals,
    pub interoperability: InteroperabilityGoals,
    pub sustainability: SustainabilityGoals,
}

#[derive(Debug)]
pub struct ScalabilityGoals {
    pub target_tps: u64,
    pub target_latency_ms: u64,
    pub target_cost_per_tx: f64,
}

#[derive(Debug)]
pub struct UsabilityGoals {
    pub onboarding_time_minutes: u32,
    pub mobile_first: bool,
    pub social_login: bool,
}

#[derive(Debug)]
pub struct InteroperabilityGoals {
    pub cross_chain_assets: bool,
    pub unified_identity: bool,
    pub composable_protocols: bool,
}

#[derive(Debug)]
pub struct SustainabilityGoals {
    pub carbon_neutral: bool,
    pub energy_efficient_consensus: bool,
    pub green_mining: bool,
}
```

## æ€»ç»“

æœ¬æ–‡æ¡£å…¨é¢ä»‹ç»äº†Web3æŠ€æœ¯æ ˆï¼š

1. **Web3æ¦‚è¿°**: æ¼”è¿›å†å²ã€æ ¸å¿ƒç‰¹å¾ã€æŠ€æœ¯æ¶æ„
2. **å‰ç«¯æŠ€æœ¯**: Web3.js/Ethers.jsã€é’±åŒ…è¿æ¥ã€å»ä¸­å¿ƒåŒ–å‰ç«¯
3. **æ™ºèƒ½åˆçº¦äº¤äº’**: åˆçº¦è°ƒç”¨ã€äº‹ä»¶ç›‘å¬ã€äº¤æ˜“ç®¡ç†
4. **å»ä¸­å¿ƒåŒ–å­˜å‚¨**: IPFSã€Arweaveã€Filecoin
5. **å»ä¸­å¿ƒåŒ–èº«ä»½**: DIDã€ENSã€å¯éªŒè¯å‡­è¯
6. **Web3é€šä¿¡**: libp2pã€Whisperã€XMTP
7. **é¢„è¨€æœº**: Chainlinkã€Band Protocolã€è‡ªå®šä¹‰é¢„è¨€æœº
8. **å¼€å‘æ¡†æ¶**: Hardhatã€Foundryã€Truffle
9. **UI/UX**: è®¾è®¡æ¨¡å¼ã€ç”¨æˆ·ä½“éªŒã€ç»„ä»¶åº“
10. **å®‰å…¨**: å‰ç«¯å®‰å…¨ã€ç­¾åéªŒè¯ã€é’“é±¼é˜²æŠ¤
11. **å®æˆ˜**: å®Œæ•´DAppå¼€å‘æµç¨‹
12. **æœªæ¥**: Account Abstractionã€Layer2ã€é“¾æŠ½è±¡ã€AIã€éšç§

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ17æ—¥  
**ä½œè€…**: Web3æŠ€æœ¯ä¸“å®¶  
**å®¡æ ¸**: å…¨æ ˆåŒºå—é“¾å·¥ç¨‹å¸ˆ

## ç›¸å…³æ–‡æ¡£

- [DeFiåº”ç”¨æŒ‡å—](./22_DEFI_APPLICATIONS.md)
- [NFTç”Ÿæ€ç³»ç»Ÿ](./23_NFT_ECOSYSTEM.md)
- [æ™ºèƒ½åˆçº¦å¼€å‘](./21_SMART_CONTRACT_DEVELOPMENT.md)
- [å®‰å…¨æœ€ä½³å®è·µ](./19_SECURITY_BEST_PRACTICES.md)

## å‚è€ƒèµ„æ–™

- Ethereum Documentation
- Web3.js Documentation
- Ethers.js Documentation
- IPFS Documentation
- W3C DID Specification

## å®ç”¨å·¥å…·

```rust
// è¾…åŠ©ä¾èµ–
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;
use chrono;
use sha3::{Digest, Keccak256};
use hex;

// ç±»å‹åˆ«å
pub type Address = String;
pub type Bytes = Vec<u8>;
pub type Hash = String;
```
